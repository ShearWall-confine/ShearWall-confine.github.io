<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini Pool: Cross-Platform Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            touch-action: none;
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        /* --- Top control stack --- */
        #ui-shell {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 20px;
            z-index: 25;
            pointer-events: none;
        }

        #action-stack {
            display: flex;
            gap: 12px;
            pointer-events: auto;
        }

        #back-home-btn,
        #settings-toggle {
            padding: 10px 18px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.15);
            background: rgba(20, 20, 30, 0.7);
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 1px;
            text-decoration: none;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease;
        }

        #settings-toggle {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        #back-home-btn:hover,
        #settings-toggle:hover {
            background: rgba(80, 80, 110, 0.8);
            transform: translateY(-1px);
        }

        #settings-panel {
            position: absolute;
            top: 80px;
            left: 20px;
            width: 260px;
            padding: 18px;
            border-radius: 16px;
            background: rgba(15, 15, 25, 0.88);
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: #fff;
            z-index: 40;
            display: none;
        }

        #settings-panel.visible {
            display: block;
        }

        #settings-panel h3 {
            margin: 0 0 10px;
            font-size: 16px;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #settings-panel label {
            font-size: 12px;
            letter-spacing: 0.5px;
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
        }

        #settings-panel input,
        #settings-panel select {
            width: 100%;
            margin-top: 6px;
        }

        #settings-panel input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.25);
            outline: none;
        }

        #settings-panel input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }

        #apply-settings {
            margin-top: 14px;
            width: 100%;
            padding: 8px 0;
            border-radius: 10px;
            border: none;
            font-weight: 600;
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            cursor: pointer;
        }

        #close-settings {
            background: none;
            border: none;
            color: rgba(255,255,255,0.6);
            font-size: 18px;
            cursor: pointer;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair; /* desktop crosshair cursor */
        }

        /* --- Scoreboard strip --- */
        #ui-layer {
            position: relative;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .player-card {
            background: rgba(20, 20, 30, 0.4);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 8px 16px;
            display: flex;
            flex-direction: column;
            min-width: 90px;
            transition: all 0.3s ease;
            opacity: 0.5;
            transform: scale(0.95);
        }

        .player-card.active {
            opacity: 1;
            transform: scale(1);
            background: rgba(40, 40, 50, 0.6);
            border-color: rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }

        .target-type {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
            color: #aaa;
        }
        
        .p1-active .target-type { color: #4facfe; }
        .p2-active .target-type { color: #f093fb; }

        .score-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            color: white;
            font-weight: 700;
            font-size: 14px;
            min-width: 120px;
        }

        .score-value {
            font-size: 20px;
            font-weight: 800;
            color: #fff;
        }

        /* --- Power column --- */
        #power-control {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 90px;
            height: 250px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            pointer-events: auto;
            border-radius: 18px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(10, 10, 20, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 16px 0;
        }

        #power-track {
            position: relative;
            width: 14px;
            height: 100%;
            background: rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            display: flex;
            justify-content: center;
        }

        #power-fill {
            position: absolute;
            bottom: 0;
            top: 0; /* fully extends, height controlled by JS */
            width: 100%;
            height: 0%; 
            background: linear-gradient(to top, #4facfe, #00f2fe);
            border-radius: 6px;
            transition: background 0.2s;
        }
        
        .p2-turn #power-fill {
            background: linear-gradient(to top, #f093fb, #f5576c);
        }

        #power-handle {
            position: absolute;
            width: 36px; /* larger touch target */
            height: 36px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            transform: translateY(0);
            cursor: pointer;
            left: 50%;
            margin-left: -18px; /* center horizontally */
            top: 0; /* initial position */
        }

        /* --- Mobile fine-tune controls --- */
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            left: 30px;
            display: none; /* hidden until touch detected */
            gap: 20px;
            z-index: 20;
            pointer-events: auto;
        }

        .fine-tune-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            touch-action: manipulation;
            transition: all 0.1s;
        }

        .fine-tune-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        /* --- Desktop keyboard hint --- */
        #desktop-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 20px;
            pointer-events: none;
            display: none; /* revealed when mouse input detected */
            white-space: nowrap;
        }
        
        .key-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
            font-weight: 600;
            margin: 0 4px;
            font-size: 10px;
        }

        /* --- Toasts & overlays --- */
        #game-toast {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(8px);
            padding: 15px 30px;
            border-radius: 12px;
            color: white;
            font-size: 16px;
            font-weight: 700;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 30;
        }

        .float-text {
            position: absolute;
            color: white;
            font-weight: 800;
            font-size: 20px;
            pointer-events: none;
            animation: popUp 0.8s ease-out forwards;
            text-shadow: 0 2px 8px rgba(0,0,0,0.6);
            z-index: 5;
        }

        #ball-hand-banner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 16px 26px;
            border-radius: 999px;
            background: rgba(10, 10, 20, 0.8);
            color: #fff;
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 0.5px;
            border: 1px solid rgba(255,255,255,0.2);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
            z-index: 35;
        }

        #ball-hand-banner.visible {
            opacity: 1;
        }

        #end-screen {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 50;
        }

        #end-screen.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .end-content {
            background: rgba(20,20,30,0.9);
            border-radius: 20px;
            padding: 30px 40px;
            text-align: center;
            color: #fff;
            border: 1px solid rgba(255,255,255,0.1);
            min-width: 260px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }

        .end-content h2 {
            margin: 0 0 20px;
            font-size: 24px;
            letter-spacing: 1px;
        }

        #restart-btn {
            padding: 10px 26px;
            border-radius: 999px;
            border: none;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 0.8px;
            cursor: pointer;
            color: #fff;
            background: linear-gradient(135deg, #00d2ff, #3a7bd5);
            box-shadow: 0 6px 20px rgba(0, 210, 255, 0.3);
        }

        #restart-btn:hover {
            transform: translateY(-1px);
        }

        @keyframes popUp {
            0% { opacity: 0; transform: translateY(0) scale(0.5); }
            50% { opacity: 1; transform: translateY(-30px) scale(1.2); }
            100% { opacity: 0; transform: translateY(-50px) scale(1); }
        }
    </style>
</head>
<body>

<div id="ui-shell">
    <div id="action-stack">
        <a id="back-home-btn" href="../index.html">← Back to Hub</a>
        <button id="settings-toggle">⚙ Settings</button>
    </div>
    <div id="ui-layer">
        <div id="p1-card" class="player-card active p1-active">
            <div class="target-type" id="p1-type">ANY</div>
            <div class="score-info">
                <span>PLAYER 1</span>
                <span class="score-value" id="p1-score">0</span>
            </div>
        </div>
        <div id="p2-card" class="player-card">
            <div class="target-type" id="p2-type">ANY</div>
            <div class="score-info">
                <span>PLAYER 2</span>
                <span class="score-value" id="p2-score">0</span>
            </div>
        </div>
    </div>
</div>

<div id="settings-panel">
    <h3>Table Settings <button id="close-settings">×</button></h3>
    <label>Ball radius <span id="ball-size-display">10px</span></label>
    <input type="range" min="6" max="100" step="1" id="ball-size-input" value="10">
    
    <label>Pocket size <span id="pocket-size-display">22px</span></label>
    <input type="range" min="10" max="200" step="1" id="pocket-size-input" value="22">

    <label>Max shot power <span id="power-max-display">200</span></label>
    <input type="range" min="80" max="10000" step="10" id="power-max-input" value="200">

    <label>Table friction <span id="friction-display">0.988</span></label>
    <input type="range" min="0" max="1" step="0.001" id="friction-input" value="0.988">
    
    <label>Felt palette</label>
    <select id="felt-select">
        <option value="midnight">Midnight Blue</option>
        <option value="classic">Classic Green</option>
        <option value="ember">Ember Night</option>
        <option value="aurora">Aurora Neon</option>
    </select>
    
    <button id="apply-settings">Apply &amp; Re-rack</button>
</div>

<div id="ball-hand-banner">Ball in hand — drag the cue ball to place it.</div>

<div id="end-screen">
    <div class="end-content">
        <h2 id="end-message">Rack complete</h2>
        <button id="restart-btn">Start New Rack</button>
    </div>
</div>

<!-- Power column -->
<div id="power-control">
    <div id="power-track">
        <div id="power-fill"></div>
        <div id="power-handle"></div>
    </div>
</div>

<!-- Mobile fine tune controls -->
<div id="mobile-controls">
    <div class="fine-tune-btn" id="btn-left">↺</div>
    <div class="fine-tune-btn" id="btn-right">↻</div>
</div>

<!-- Desktop hint -->
<div id="desktop-hint">
    Use <span class="key-badge">←</span> <span class="key-badge">→</span> to Aim &nbsp;|&nbsp; Hold <span class="key-badge">SPACE</span> to Shoot
</div>

<div id="game-toast"></div>
<canvas id="gameCanvas"></canvas>

<script>
// --- Config ---
const CONFIG = {
    BALL_RADIUS: 10,
    POCKET_RADIUS: 22,
    CUSHION_SIZE: 20,
    FRICTION: 0.988,
    WALL_BOUNCE: 0.75,
    BALL_BOUNCE: 0.94,
    MAX_POWER: 200,
    POWER_SCALE: 0.14,
    STOP_VELOCITY: 0.05,
    TRAIL_FADE: 0.07,
    AIM_SENSITIVITY_TOUCH: 0.005,
    AIM_SENSITIVITY_KEY: 0.01
};

const TYPE = { CUE: 0, SOLID: 1, STRIPE: 2, BLACK: 3 };
const PALETTE = {
    BG: '#050505',
    FELT: ['#001a33', '#000814'],
    P1_COLOR: '#4facfe',
    P2_COLOR: '#f093fb',
    SOLIDS: ['#FFD700', '#FF6B6B', '#4ECDC4', '#1A535C', '#FF9F1C', '#2E86AB', '#8D99AE'],
    STRIPES: ['#FFE66D', '#FF8C94', '#96CEB4', '#45B8AC', '#FFAD60', '#5DADE2', '#A3E4D7']
};

const BASE_CONFIG = {
    BALL_RADIUS: CONFIG.BALL_RADIUS,
    POCKET_RADIUS: CONFIG.POCKET_RADIUS,
    POWER_SCALE: CONFIG.POWER_SCALE,
    MAX_POWER: CONFIG.MAX_POWER,
    FRICTION: CONFIG.FRICTION
};

const SETTINGS = {
    ballRadius: CONFIG.BALL_RADIUS,
    pocketRadius: CONFIG.POCKET_RADIUS,
    feltScheme: 'midnight',
    maxPower: CONFIG.MAX_POWER,
    friction: CONFIG.FRICTION
};

const FELT_SCHEMES = {
    midnight: ['#001a33', '#000814'],
    classic: ['#0b4d0b', '#062b06'],
    ember: ['#331111', '#120505'],
    aurora: ['#002b36', '#00111b']
};

const STATE = {
    turn: 1,
    assigned: false,
    p1Group: null,
    aimAngle: Math.PI/2,
    power: 0,
    isCharging: false,
    spaceCharging: false, // keyboard charging flag
    spaceChargeDir: 1,    // toggles charge direction
    sunkThisTurn: [],
    foul: false,
    gameOver: false,
    canShoot: true,
    inputType: 'unknown', // 'mouse' or 'touch'
    scores: {1: 0, 2: 0},
    ballInHand: false
};

class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vector(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() { let m = this.mag(); return m === 0 ? new Vector(0,0) : new Vector(this.x / m, this.y / m); }
    dist(v) { return Math.sqrt((this.x - v.x) ** 2 + (this.y - v.y) ** 2); }
    
    // Added missing dot-product helper
    static dot(v1, v2) { return v1.x * v2.x + v1.y * v2.y; }
}

class Ball {
    constructor(x, y, type, color, id) {
        this.pos = new Vector(x, y);
        this.vel = new Vector(0, 0);
        this.type = type;
        this.color = color;
        this.id = id;
        this.active = true;
    }

    update() {
        if (!this.active) return;
        if (this.vel.mag() > 1) {
            trailCtx.beginPath();
            if (this.type === TYPE.SOLID || this.type === TYPE.BLACK || this.type === TYPE.CUE) {
                trailCtx.arc(this.pos.x, this.pos.y, CONFIG.BALL_RADIUS * 0.8, 0, Math.PI * 2);
                trailCtx.fillStyle = this.type === TYPE.CUE ? 'rgba(255,255,255,0.2)' : this.color;
                trailCtx.fill();
            } else {
                trailCtx.arc(this.pos.x, this.pos.y, CONFIG.BALL_RADIUS * 0.6, 0, Math.PI * 2);
                trailCtx.fillStyle = this.color;
                trailCtx.globalAlpha = 0.4;
                trailCtx.fill();
                trailCtx.globalAlpha = 1.0;
            }
        }
        this.pos = this.pos.add(this.vel);
        this.vel = this.vel.mult(CONFIG.FRICTION);
        if (this.vel.mag() < CONFIG.STOP_VELOCITY) this.vel = new Vector(0, 0);

        const bound = CONFIG.CUSHION_SIZE + CONFIG.BALL_RADIUS;
        if (this.pos.x < bound) { this.pos.x = bound; this.vel.x *= -CONFIG.WALL_BOUNCE; }
        if (this.pos.x > logicalWidth - bound) { this.pos.x = logicalWidth - bound; this.vel.x *= -CONFIG.WALL_BOUNCE; }
        if (this.pos.y < bound) { this.pos.y = bound; this.vel.y *= -CONFIG.WALL_BOUNCE; }
        if (this.pos.y > logicalHeight - bound) { this.pos.y = logicalHeight - bound; this.vel.y *= -CONFIG.WALL_BOUNCE; }
    }

    draw(ctx) {
        if (!this.active) return;
        const x = this.pos.x;
        const y = this.pos.y;
        const r = CONFIG.BALL_RADIUS;

        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.beginPath(); ctx.arc(x + r*0.3, y + r*0.3, r, 0, Math.PI * 2); ctx.fill();

        if (this.type === TYPE.CUE) {
            let grad = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.2, x, y, r);
            grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#ccc');
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
        } else if (this.type === TYPE.BLACK) {
            let grad = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.2, x, y, r);
            grad.addColorStop(0, '#444'); grad.addColorStop(1, '#000');
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#fff"; ctx.font = "bold 10px Inter";
            ctx.textAlign = "center"; ctx.textBaseline="middle"; ctx.fillText("8", x, y+0.5);
        } else if (this.type === TYPE.SOLID) {
            let grad = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.2, x, y, r);
            grad.addColorStop(0, adjustBrightness(this.color, 60));
            grad.addColorStop(0.3, this.color);
            grad.addColorStop(1, adjustBrightness(this.color, -50));
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
        } else if (this.type === TYPE.STRIPE) {
            ctx.fillStyle = "#111"; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = this.color; ctx.lineWidth = r * 0.6;
            ctx.beginPath(); ctx.arc(x, y, r*0.6, 0, Math.PI*2); ctx.stroke();
            let glare = ctx.createLinearGradient(x-r, y-r, x+r, y+r);
            glare.addColorStop(0, "rgba(255,255,255,0.4)"); glare.addColorStop(0.5, "rgba(255,255,255,0)");
            ctx.fillStyle = glare; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
        }
    }
}

// --- Globals ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const trailCanvas = document.createElement('canvas');
const trailCtx = trailCanvas.getContext('2d');

const uiP1 = document.getElementById('p1-card');
const uiP2 = document.getElementById('p2-card');
const uiType1 = document.getElementById('p1-type');
const uiType2 = document.getElementById('p2-type');
const uiPowerControl = document.getElementById('power-control');
const uiPowerFill = document.getElementById('power-fill');
const uiPowerHandle = document.getElementById('power-handle');
const uiToast = document.getElementById('game-toast');
const uiMobileControls = document.getElementById('mobile-controls');
const uiDesktopHint = document.getElementById('desktop-hint');
const uiSettingsToggle = document.getElementById('settings-toggle');
const uiSettingsPanel = document.getElementById('settings-panel');
const uiCloseSettings = document.getElementById('close-settings');
const uiBallRange = document.getElementById('ball-size-input');
const uiPocketRange = document.getElementById('pocket-size-input');
const uiFeltSelect = document.getElementById('felt-select');
const uiApplySettings = document.getElementById('apply-settings');
const uiBallDisplay = document.getElementById('ball-size-display');
const uiPocketDisplay = document.getElementById('pocket-size-display');
const uiPowerMaxRange = document.getElementById('power-max-input');
const uiPowerMaxDisplay = document.getElementById('power-max-display');
const uiFrictionRange = document.getElementById('friction-input');
const uiFrictionDisplay = document.getElementById('friction-display');
const uiScore1 = document.getElementById('p1-score');
const uiScore2 = document.getElementById('p2-score');
const uiBallHandBanner = document.getElementById('ball-hand-banner');
const uiEndScreen = document.getElementById('end-screen');
const uiEndMessage = document.getElementById('end-message');
const uiRestartBtn = document.getElementById('restart-btn');

if (uiRestartBtn) {
    uiRestartBtn.addEventListener('click', () => {
        hideEndScreen();
        resetGame();
    });
}

let logicalWidth, logicalHeight;
let balls = [];
let pockets = [];
let whiteBall;
let aimTouchStart = null;
let aimAngleStart = 0;
let placingBall = false;
let lastPlacementValid = false;

// --- Init ---
function resize() {
    const dpr = window.devicePixelRatio || 1;
    logicalWidth = window.innerWidth;
    logicalHeight = window.innerHeight;
    canvas.width = logicalWidth * dpr; canvas.height = logicalHeight * dpr;
    canvas.style.width = logicalWidth + "px"; canvas.style.height = logicalHeight + "px";
    ctx.resetTransform(); ctx.scale(dpr, dpr);
    trailCanvas.width = logicalWidth * dpr; trailCanvas.height = logicalHeight * dpr;
    trailCtx.resetTransform(); trailCtx.scale(dpr, dpr);
    const off = CONFIG.CUSHION_SIZE * 0.8;
    pockets = [
        new Vector(off, off), new Vector(logicalWidth/2, off-4), new Vector(logicalWidth-off, off),
        new Vector(off, logicalHeight-off), new Vector(logicalWidth/2, logicalHeight-off+4), new Vector(logicalWidth-off, logicalHeight-off)
    ];
}

function init() {
    resize();
    window.addEventListener('resize', resize);
    resetGame();
    setupInputs();
    setupSettingsPanel();
    requestAnimationFrame(loop);
}

function setupInputs() {
    // Canvas Touch Aim (Coarse)
    canvas.addEventListener('touchstart', e => {
        STATE.inputType = 'touch'; updateDeviceUI();
        handleAimStart(e);
    }, {passive: false});
    window.addEventListener('touchmove', e => handleAimMove(e), {passive: false});
    
    // Mouse Aim (Coarse)
    canvas.addEventListener('mousedown', e => {
        STATE.inputType = 'mouse'; updateDeviceUI();
        handleAimStart(e);
    });
    window.addEventListener('mousemove', e => {
        STATE.inputType = 'mouse'; updateDeviceUI();
        handleAimMove(e);
    });

    // Mobile Fine Tune Buttons
    const btnLeft = document.getElementById('btn-left');
    const btnRight = document.getElementById('btn-right');
    const fineTune = (dir) => {
        if(!STATE.canShoot) return;
        STATE.aimAngle += dir * 0.05; // Small step
        if(navigator.vibrate) navigator.vibrate(5);
    };
    btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); fineTune(-1); });
    btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); fineTune(1); });
    // Also support click for testing
    btnLeft.addEventListener('mousedown', (e) => { e.preventDefault(); fineTune(-1); });
    btnRight.addEventListener('mousedown', (e) => { e.preventDefault(); fineTune(1); });

    // Power Slider
    uiPowerControl.addEventListener('touchstart', handlePowerStart, {passive: false});
    uiPowerControl.addEventListener('touchmove', handlePowerMove, {passive: false});
    uiPowerControl.addEventListener('touchend', handlePowerEnd, {passive: false});
    uiPowerControl.addEventListener('mousedown', handlePowerStart);
    window.addEventListener('mouseup', handlePowerEnd);
    window.addEventListener('mouseup', handlePlacementEnd);
    window.addEventListener('touchend', handlePlacementEnd);

    // Keyboard
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    window.addEventListener('wheel', handleWheel); // Mouse wheel support
}

function setupSettingsPanel() {
    if (!uiSettingsToggle) return;
    uiBallRange.value = CONFIG.BALL_RADIUS;
    uiPocketRange.value = CONFIG.POCKET_RADIUS;
    uiBallDisplay.innerText = `${CONFIG.BALL_RADIUS}px`;
    uiPocketDisplay.innerText = `${CONFIG.POCKET_RADIUS}px`;
    uiFeltSelect.value = SETTINGS.feltScheme;
    uiPowerMaxRange.value = CONFIG.MAX_POWER;
    uiPowerMaxDisplay.innerText = `${CONFIG.MAX_POWER}`;
    uiFrictionRange.value = CONFIG.FRICTION.toFixed(3);
    uiFrictionDisplay.innerText = CONFIG.FRICTION.toFixed(3);

    const togglePanel = (show) => {
        uiSettingsPanel.classList[show ? 'add' : 'remove']('visible');
    };

    uiSettingsToggle.addEventListener('click', () => togglePanel(!uiSettingsPanel.classList.contains('visible')));
    uiCloseSettings.addEventListener('click', () => togglePanel(false));

    uiBallRange.addEventListener('input', () => {
        SETTINGS.ballRadius = Number(uiBallRange.value);
        uiBallDisplay.innerText = `${SETTINGS.ballRadius}px`;
    });
    uiPocketRange.addEventListener('input', () => {
        SETTINGS.pocketRadius = Number(uiPocketRange.value);
        uiPocketDisplay.innerText = `${SETTINGS.pocketRadius}px`;
    });
    uiFeltSelect.addEventListener('change', () => {
        SETTINGS.feltScheme = uiFeltSelect.value;
    });
    uiPowerMaxRange.addEventListener('input', () => {
        SETTINGS.maxPower = Number(uiPowerMaxRange.value);
        uiPowerMaxDisplay.innerText = `${SETTINGS.maxPower}`;
    });
    uiFrictionRange.addEventListener('input', () => {
        SETTINGS.friction = Number(uiFrictionRange.value);
        uiFrictionDisplay.innerText = SETTINGS.friction.toFixed(3);
    });

    uiApplySettings.addEventListener('click', () => {
        applyCustomSettings();
        togglePanel(false);
    });
}

function applyCustomSettings() {
    CONFIG.BALL_RADIUS = SETTINGS.ballRadius;
    CONFIG.POCKET_RADIUS = SETTINGS.pocketRadius;
    PALETTE.FELT = FELT_SCHEMES[SETTINGS.feltScheme] || FELT_SCHEMES.midnight;
    CONFIG.POWER_SCALE = BASE_CONFIG.POWER_SCALE * (BASE_CONFIG.BALL_RADIUS / CONFIG.BALL_RADIUS);
    CONFIG.MAX_POWER = SETTINGS.maxPower;
    CONFIG.FRICTION = SETTINGS.friction;
    showToast("Settings applied — new rack ready");
    resetGame();
}

function updateDeviceUI() {
    if (STATE.inputType === 'touch') {
        uiMobileControls.style.display = 'flex';
        uiDesktopHint.style.display = 'none';
    } else {
        uiMobileControls.style.display = 'none';
        uiDesktopHint.style.display = 'block';
    }
}

// --- Input Handlers ---
function handleAimStart(e) {
    if (STATE.gameOver) return;
    if (STATE.ballInHand && STATE.canShoot) {
        e.preventDefault();
        placingBall = true;
        attemptPlaceCueBall(getEventPos(e));
        return;
    }
    if (!STATE.canShoot || STATE.spaceCharging) return;
    if (e.target !== canvas) return;
    e.preventDefault();
    aimTouchStart = getEventPos(e);
    aimAngleStart = STATE.aimAngle;
}

function handleAimMove(e) {
    if (STATE.gameOver) return;
    if (STATE.ballInHand && placingBall) {
        e.preventDefault();
        attemptPlaceCueBall(getEventPos(e));
        return;
    }
    if (!STATE.canShoot || STATE.isCharging || STATE.spaceCharging) return;
    const pos = getEventPos(e);

    if (STATE.inputType === 'mouse') {
        // Mouse aims along the cue ball to cursor vector
        const angle = Math.atan2(pos.y - whiteBall.pos.y, pos.x - whiteBall.pos.x);
        if (!isNaN(angle)) STATE.aimAngle = angle;
        return;
    }

    if (!aimTouchStart) return;
    let dy = pos.y - aimTouchStart.y;
    let sensitivity = CONFIG.AIM_SENSITIVITY_TOUCH;
    STATE.aimAngle = aimAngleStart + (dy * sensitivity); 
}

function handleKeyDown(e) {
    if (!STATE.canShoot || STATE.gameOver) return;
    STATE.inputType = 'mouse'; updateDeviceUI();
    
    const step = e.shiftKey ? 0.05 : 0.005; // Shift for fast turn

    if (e.code === 'ArrowLeft') STATE.aimAngle -= step;
    if (e.code === 'ArrowRight') STATE.aimAngle += step;
    
    if (e.code === 'Space' && !STATE.spaceCharging && !e.repeat) {
        STATE.spaceCharging = true;
        STATE.power = 0;
        STATE.spaceChargeDir = 1;
    }
}

function handleKeyUp(e) {
    if (STATE.gameOver) return;
    if (e.code === 'Space' && STATE.spaceCharging) {
        STATE.spaceCharging = false;
        shoot();
        STATE.power = 0;
        updatePowerUI(0);
    }
}

function handleWheel(e) {
    if (!STATE.canShoot || STATE.ballInHand || STATE.gameOver) return;
    STATE.aimAngle += e.deltaY * 0.001;
}

// Power Slider Logic
function handlePowerStart(e) {
    if (!STATE.canShoot || STATE.spaceCharging || STATE.ballInHand || STATE.gameOver) return;
    e.preventDefault();
    STATE.isCharging = true;
    updatePowerUI(0);
}

function handlePowerMove(e) {
    if (!STATE.isCharging) return;
    const pos = getEventPos(e);
    const rect = document.getElementById('power-track').getBoundingClientRect();
    let relativeY = pos.y - rect.top;
    let percent = Math.max(0, Math.min(1, relativeY / rect.height));
    STATE.power = percent;
    updatePowerUI(percent);
}

function handlePowerEnd(e) {
    if (!STATE.isCharging) return;
    STATE.isCharging = false;
    if (STATE.power > 0.1) shoot();
    STATE.power = 0;
    updatePowerUI(0);
}

function getEventPos(e) {
    if (e.touches && e.touches.length > 0) return new Vector(e.touches[0].clientX, e.touches[0].clientY);
    return new Vector(e.clientX, e.clientY);
}

function clampToTableBounds(pos) {
    const bound = CONFIG.CUSHION_SIZE + CONFIG.BALL_RADIUS;
    const x = Math.max(bound, Math.min(logicalWidth - bound, pos.x));
    const y = Math.max(bound, Math.min(logicalHeight - bound, pos.y));
    return new Vector(x, y);
}

function isPlacementValid(pos) {
    for (let b of balls) {
        if (b === whiteBall || !b.active) continue;
        if (pos.dist(b.pos) < CONFIG.BALL_RADIUS * 2) return false;
    }
    return true;
}

function attemptPlaceCueBall(rawPos) {
    if (!rawPos) return false;
    const bounded = clampToTableBounds(rawPos);
    if (!isPlacementValid(bounded)) {
        if (!placingBall) showToast("Cue ball overlaps another ball");
        lastPlacementValid = false;
        return false;
    }
    whiteBall.active = true;
    whiteBall.pos = bounded;
    whiteBall.vel = new Vector(0,0);
    lastPlacementValid = true;
    return true;
}

function handlePlacementEnd() {
    if (!STATE.ballInHand || !placingBall) return;
    placingBall = false;
    if (lastPlacementValid) {
        STATE.ballInHand = false;
        updateBallInHandBanner();
        showToast("Cue ball locked in");
    } else {
        updateBallInHandBanner();
        showToast("Pick a legal spot");
    }
}

// --- Logic ---
function updatePowerUI(percent) {
    uiPowerFill.style.height = (percent * 100) + "%";
    uiPowerFill.style.top = "0"; 
    uiPowerHandle.style.top = (percent * 100) + "%";
    
    if (STATE.turn === 2) uiPowerControl.classList.add('p2-turn');
    else uiPowerControl.classList.remove('p2-turn');
}

function shoot() {
    if (STATE.ballInHand || STATE.gameOver) return;
    STATE.canShoot = false;
    let force = STATE.power * CONFIG.MAX_POWER;
    let dir = new Vector(Math.cos(STATE.aimAngle), Math.sin(STATE.aimAngle));
    whiteBall.vel = dir.mult(force * CONFIG.POWER_SCALE);
    STATE.sunkThisTurn = [];
    STATE.foul = false;
    if(navigator.vibrate) navigator.vibrate(20); // haptic feedback
}

function resetGame() {
    hideEndScreen();
    balls = [];
    STATE.turn = 1; STATE.assigned = false; STATE.p1Group = null;
    STATE.foul = false; STATE.gameOver = false; STATE.sunkThisTurn = [];
    STATE.ballInHand = false; placingBall = false; lastPlacementValid = false;
    STATE.scores = {1: 0, 2: 0};
    updateBallInHandBanner();
    trailCtx.clearRect(0,0,logicalWidth,logicalHeight);

    whiteBall = new Ball(logicalWidth * 0.25, logicalHeight / 2, TYPE.CUE, '#fff', 0);
    balls.push(whiteBall);

    const startX = logicalWidth * 0.7;
    const startY = logicalHeight / 2;
    const r = CONFIG.BALL_RADIUS;
    const rackPattern = [1, 1, 0, 0, 2, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0]; 
    let solids = [...PALETTE.SOLIDS], stripes = [...PALETTE.STRIPES];
    let ballIdx = 0;

    for (let col = 0; col < 5; col++) {
        for (let row = 0; row <= col; row++) {
            let x = startX + col * (r * 2 * 0.866 + 1);
            let y = startY - col * (r + 0.5) + row * (r * 2 + 1);
            let typeCode = rackPattern[ballIdx];
            let type, color, id;
            if (typeCode === 2) { type = TYPE.BLACK; color = '#000'; id = 8; }
            else if (typeCode === 0) { type = TYPE.SOLID; color = solids.shift()||'#888'; id=ballIdx+1; }
            else { type = TYPE.STRIPE; color = stripes.shift()||'#888'; id=ballIdx+9; }
            balls.push(new Ball(x, y, type, color, id));
            ballIdx++;
        }
    }
    updateUI();
    showToast("GAME START");
}

function checkTurn() {
    const isMoving = balls.some(b => b.active && b.vel.mag() > CONFIG.STOP_VELOCITY);
    if (!isMoving && !STATE.canShoot && !STATE.gameOver) {
        resolveTurn();
        STATE.canShoot = true;
    }
}

function resolveTurn() {
    let switchTurn = true;
    let message = "";
    if (STATE.foul) {
        message = "FOUL! BALL IN HAND";
        resetWhiteBall(true);
        switchTurn = true;
    } else if (STATE.sunkThisTurn.includes(TYPE.BLACK)) {
        let myType = (STATE.turn === 1) ? STATE.p1Group : (STATE.p1Group === TYPE.SOLID ? TYPE.STRIPE : TYPE.SOLID);
        let myRemaining = countRemaining(myType);
        if (myRemaining > 0 || !STATE.assigned) { message = `PLAYER ${STATE.turn} LOST`; STATE.gameOver = true; }
        else { message = `PLAYER ${STATE.turn} WINS!`; STATE.gameOver = true; }
        STATE.canShoot = false;
        showToast(message);
        showEndScreen(message);
        return;
    } else if (STATE.sunkThisTurn.length > 0) {
        let firstSunk = STATE.sunkThisTurn[0];
        if (!STATE.assigned) {
            if (firstSunk === TYPE.SOLID) { STATE.p1Group = TYPE.SOLID; STATE.assigned = true; message = "P1: SOLIDS"; switchTurn = false; }
            else if (firstSunk === TYPE.STRIPE) { STATE.p1Group = TYPE.STRIPE; STATE.assigned = true; message = "P1: STRIPES"; switchTurn = false; }
        } else {
            let myGroup = (STATE.turn === 1) ? STATE.p1Group : (STATE.p1Group === TYPE.SOLID ? TYPE.STRIPE : TYPE.SOLID);
            if (STATE.sunkThisTurn.includes(myGroup)) { switchTurn = false; message = "GOOD SHOT"; }
            else { switchTurn = true; message = "WRONG BALL"; }
        }
    } else { switchTurn = true; }

    if (switchTurn) STATE.turn = STATE.turn === 1 ? 2 : 1;
    if (message) showToast(message);
    updateUI();
    updateBallInHandBanner();
}

function countRemaining(type) { return type ? balls.filter(b => b.active && b.type === type).length : 0; }
function resetWhiteBall(withBallInHand = false) {
    whiteBall.active = true; whiteBall.vel = new Vector(0,0);
    whiteBall.pos = new Vector(logicalWidth * 0.25, logicalHeight / 2);
    STATE.ballInHand = withBallInHand;
    placingBall = false;
    lastPlacementValid = false;
    updateBallInHandBanner();
}

function resolveCollisions() {
    for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
            let b1 = balls[i]; let b2 = balls[j];
            if (!b1.active || !b2.active) continue;
            let dist = b1.pos.dist(b2.pos);
            if (dist < CONFIG.BALL_RADIUS * 2) {
                let normal = b2.pos.sub(b1.pos).normalize();
                let overlap = CONFIG.BALL_RADIUS * 2 - dist;
                b1.pos = b1.pos.sub(normal.mult(overlap * 0.5));
                b2.pos = b2.pos.add(normal.mult(overlap * 0.5));
                let relVel = b1.vel.sub(b2.vel);
                let sepVel = Vector.dot(relVel, normal);
                let newSepVel = -sepVel * CONFIG.BALL_BOUNCE;
                let sepVelVec = normal.mult(newSepVel - sepVel);
                b1.vel = b1.vel.add(sepVelVec.mult(0.5));
                b2.vel = b2.vel.sub(sepVelVec.mult(0.5));
            }
        }
    }
    for (let b of balls) {
        if (!b.active) continue;
        for (let p of pockets) {
            if (b.pos.dist(p) < CONFIG.POCKET_RADIUS) {
                if (b.type === TYPE.CUE) { STATE.foul = true; b.active = false; }
                else {
                    b.active = false; b.vel = new Vector(0,0);
                    STATE.sunkThisTurn.push(b.type);
                    STATE.scores[STATE.turn] = (STATE.scores[STATE.turn] || 0) + 1;
                    spawnFloatText("+1", p.x, p.y);
                    updateUI();
                }
            }
        }
    }
}

function spawnFloatText(text, x, y) {
    const el = document.createElement('div');
    el.className = 'float-text'; el.innerText = text;
    el.style.left = Math.min(x, logicalWidth-50)+'px'; el.style.top = Math.min(y, logicalHeight-50)+'px';
    document.body.appendChild(el); setTimeout(() => el.remove(), 800);
}
function showToast(msg) { uiToast.innerText = msg; uiToast.style.opacity = "1"; setTimeout(() => uiToast.style.opacity = "0", 2000); }
function updateBallInHandBanner() {
    if (!uiBallHandBanner) return;
    if (STATE.ballInHand && !STATE.gameOver) {
        uiBallHandBanner.innerText = `Ball in hand — Player ${STATE.turn}, drag the cue ball to place it.`;
        uiBallHandBanner.classList.add('visible');
    } else {
        uiBallHandBanner.classList.remove('visible');
    }
}
function showEndScreen(msg) {
    if (uiEndMessage) uiEndMessage.innerText = msg;
    if (uiEndScreen) uiEndScreen.classList.add('visible');
    updateBallInHandBanner();
}
function hideEndScreen() {
    if (uiEndScreen) uiEndScreen.classList.remove('visible');
}
function updateUI() {
    if (STATE.turn === 1) { uiP1.classList.add('active', 'p1-active'); uiP2.classList.remove('active', 'p2-active'); }
    else { uiP1.classList.remove('active', 'p1-active'); uiP2.classList.add('active', 'p2-active'); }
    if (!STATE.assigned) { uiType1.innerText = "ANY"; uiType2.innerText = "ANY"; }
    else {
        uiType1.innerText = STATE.p1Group === TYPE.SOLID ? "SOLIDS ●" : "STRIPES ◎";
        uiType2.innerText = STATE.p1Group === TYPE.SOLID ? "STRIPES ◎" : "SOLIDS ●";
    }
    if (uiScore1) uiScore1.innerText = STATE.scores[1];
    if (uiScore2) uiScore2.innerText = STATE.scores[2];
}
function adjustBrightness(col, amt) {
    let usePound = false; if (col[0] == "#") { col = col.slice(1); usePound = true; }
    let num = parseInt(col,16); let r = (num >> 16) + amt; let b = ((num >> 8) & 0x00FF) + amt; let g = (num & 0x0000FF) + amt;
    r = r > 255 ? 255 : (r < 0 ? 0 : r); b = b > 255 ? 255 : (b < 0 ? 0 : b); g = g > 255 ? 255 : (g < 0 ? 0 : g);
    return (usePound?"#":"") + (g | (b << 8) | (r << 16)).toString(16).padStart(6,0);
}

function loop() {
    ctx.clearRect(0, 0, logicalWidth, logicalHeight);
    
    // Space Charging Logic
    if (STATE.spaceCharging) {
        STATE.power += 0.02 * STATE.spaceChargeDir;
        if (STATE.power >= 1) { STATE.power = 1; STATE.spaceChargeDir = -1; }
        if (STATE.power <= 0) { STATE.power = 0; STATE.spaceChargeDir = 1; }
        updatePowerUI(STATE.power);
    }

    trailCtx.globalCompositeOperation = 'destination-out';
    trailCtx.fillStyle = `rgba(0, 0, 0, ${CONFIG.TRAIL_FADE})`;
    trailCtx.fillRect(0, 0, logicalWidth, logicalHeight);
    trailCtx.globalCompositeOperation = 'source-over';

    let felt = ctx.createRadialGradient(logicalWidth/2, logicalHeight/2, logicalWidth*0.2, logicalWidth/2, logicalHeight/2, logicalWidth);
    felt.addColorStop(0, PALETTE.FELT[0]); felt.addColorStop(1, PALETTE.FELT[1]);
    ctx.fillStyle = felt; ctx.fillRect(0, 0, logicalWidth, logicalHeight);
    ctx.drawImage(trailCanvas, 0, 0, logicalWidth, logicalHeight);
    
    const c = CONFIG.CUSHION_SIZE;
    ctx.fillStyle = "#0a0a10";
    ctx.fillRect(0,0,logicalWidth,c); ctx.fillRect(0,logicalHeight-c,logicalWidth,c);
    ctx.fillRect(0,0,c,logicalHeight); ctx.fillRect(logicalWidth-c,0,c,logicalHeight);
    ctx.strokeStyle = "rgba(255,255,255,0.1)"; ctx.lineWidth=1;
    ctx.strokeRect(c,c,logicalWidth-c*2,logicalHeight-c*2);
    
    ctx.fillStyle = "#000";
    for(let p of pockets) { ctx.beginPath(); ctx.arc(p.x, p.y, CONFIG.POCKET_RADIUS, 0, Math.PI*2); ctx.fill(); }

    resolveCollisions();
    checkTurn();

    for(let b of balls) { b.update(); b.draw(ctx); }
    
    if (STATE.canShoot && !STATE.gameOver && !STATE.ballInHand) {
        let dir = new Vector(Math.cos(STATE.aimAngle), Math.sin(STATE.aimAngle));
        let start = whiteBall.pos;
        let end = start.add(dir.mult(600));
        let color = STATE.turn === 1 ? PALETTE.P1_COLOR : PALETTE.P2_COLOR;
        
        ctx.beginPath(); ctx.moveTo(start.x, start.y); ctx.lineTo(end.x, end.y);
        ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.setLineDash([8, 8]); ctx.stroke(); ctx.setLineDash([]);
        ctx.beginPath(); ctx.arc(start.x, start.y, CONFIG.BALL_RADIUS + 15, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255,255,255,0.1)"; ctx.lineWidth = 1; ctx.stroke();
    }
    requestAnimationFrame(loop);
}

init();
</script>
</body>
</html>