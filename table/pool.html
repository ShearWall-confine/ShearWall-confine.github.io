<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini 台球: 跨平台专业版</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <!-- Noto Sans SC for better Chinese rendering -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            touch-action: none;
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        /* --- 顶部控制栏 (嵌入顶部库边) --- */
        #ui-shell {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 6px 24px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 12px;
            z-index: 20;
            pointer-events: none;
        }

        #action-stack {
            display: flex;
            gap: 12px;
            pointer-events: auto;
        }

        #back-home-btn,
        #settings-toggle {
            padding: 6px 14px;
            border-radius: 999px;
            border: none;
            background: transparent;
            color: rgba(240,240,255,0.9);
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-decoration: none;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease;
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
        }

        #settings-toggle {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        #back-home-btn:hover,
        #settings-toggle:hover {
            background: none;
            transform: translateY(-1px);
            text-shadow: 0 0 6px rgba(255,255,255,0.5);
        }

        /* --- 设置面板与遮罩 --- */
        #settings-panel {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 40;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #settings-panel.visible {
            display: flex;
        }

        .settings-content {
            width: 60vw;
            max-width: 420px;
            max-height: 60vh;
            padding: 18px 20px;
            border-radius: 16px;
            background: rgba(15, 15, 25, 0.96);
            border: 1px solid rgba(255,255,255,0.12);
            box-sizing: border-box;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            color: #fff;
        }

        #settings-panel h3 {
            margin: 0 0 10px;
            font-size: 16px;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #settings-panel label {
            font-size: 13px;
            letter-spacing: 0.5px;
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            color: #ddd;
        }

        #settings-panel input,
        #settings-panel select {
            width: 100%;
            margin-top: 6px;
        }

        #settings-panel input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.25);
            outline: none;
        }

        #settings-panel input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }

        .select-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 13px;
            gap: 8px;
        }

        .select-row label {
            flex: 1;
        }

        .select-row select {
            flex: 1.2;
            background: rgba(10,10,20,0.85);
            color: #fff;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.25);
            padding: 4px 6px;
            font-size: 12px;
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
        }

        /* 离线模拟预览线 */
        .offline-preview {
            pointer-events: none;
        }

        .spin-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .spin-row input[type="range"] {
            flex: 1;
        }

        .spin-btn {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.4);
            background: rgba(15,15,25,0.9);
            color: #fff;
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
            padding: 0;
        }

        .spin-btn:active {
            background: rgba(60,60,80,0.9);
            transform: scale(0.96);
        }

        #apply-settings {
            margin: 8px 0 12px 0;
            width: 100%;
            padding: 8px 0;
            border-radius: 10px;
            border: none;
            font-weight: 600;
            font-size: 14px;
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            cursor: pointer;
        }

        #close-settings {
            background: none;
            border: none;
            color: rgba(255,255,255,0.6);
            font-size: 18px;
            cursor: pointer;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair; /* 桌面端准星 */
            z-index: 1; /* 台面与球在 UI 层之下 */
        }

        /* --- 计分板 (嵌入台呢) --- */
        #ui-layer {
            display: none; /* 视觉计分板直接绘制在 Canvas 上 */
        }

        /* --- (Legacy) DOM 力度条: 隐藏, 逻辑移入底部库边 --- */
        #power-control {
            display: none;
        }

        /* --- 移动端微调控制 --- */
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            left: 30px;
            display: none; /* 触摸检测后显示 */
            gap: 20px;
            z-index: 20;
            pointer-events: auto;
        }

        .fine-tune-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            touch-action: manipulation;
            transition: all 0.1s;
        }

        .fine-tune-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        /* --- 移动端确认击球按钮 (仅离线模式) --- */
        #confirm-shot-btn {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
            transform-origin: center;
            padding: 8px 16px;
            border-radius: 999px;
            border: none;
            background: transparent;
            color: rgba(240,240,255,0.9);
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 1px;
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
            cursor: pointer;
            z-index: 25;
            display: none; /* 默认隐藏 */
            touch-action: manipulation;
            transition: all 0.2s ease;
            white-space: nowrap;
            pointer-events: auto;
            width: auto;
            height: auto;
        }

        #confirm-shot-btn:hover,
        #confirm-shot-btn:active {
            background: none;
            transform: translateY(-50%) rotate(-90deg) translateX(-1px);
            text-shadow: 0 0 6px rgba(255,255,255,0.5);
        }

        #confirm-shot-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* --- 桌面端键盘提示 --- */
        #desktop-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 13px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 18px;
            border-radius: 20px;
            pointer-events: none;
            display: none; /* 鼠标输入检测后显示 */
            white-space: nowrap;
            backdrop-filter: blur(4px);
        }
        
        .key-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
            font-weight: 600;
            margin: 0 4px;
            font-size: 11px;
        }

        /* --- 消息提示 & 遮罩 --- */
        #game-toast {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(8px);
            padding: 10px 24px;
            border-radius: 12px;
            color: white;
            font-size: 15px;
            font-weight: 700;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 30;
            white-space: nowrap;
        }

        .float-text {
            position: absolute;
            color: white;
            font-weight: 800;
            font-size: 20px;
            pointer-events: none;
            animation: popUp 0.8s ease-out forwards;
            text-shadow: 0 2px 8px rgba(0,0,0,0.6);
            z-index: 5;
        }

        #ball-hand-banner {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 22px;
            border-radius: 999px;
            background: rgba(10, 10, 20, 0.8);
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.5px;
            border: 1px solid rgba(255,255,255,0.2);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
            z-index: 35;
            white-space: nowrap;
        }

        #ball-hand-banner.visible {
            opacity: 1;
        }

        #end-screen {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 50;
        }

        #end-screen.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .end-content {
            background: rgba(20,20,30,0.9);
            border-radius: 20px;
            padding: 30px 40px;
            text-align: center;
            color: #fff;
            border: 1px solid rgba(255,255,255,0.1);
            min-width: 260px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }

        .end-content h2 {
            margin: 0 0 20px;
            font-size: 24px;
            letter-spacing: 1px;
        }

        #restart-btn {
            padding: 10px 26px;
            border-radius: 999px;
            border: none;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 0.8px;
            cursor: pointer;
            color: #fff;
            background: linear-gradient(135deg, #00d2ff, #3a7bd5);
            box-shadow: 0 6px 20px rgba(0, 210, 255, 0.3);
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
        }

        #restart-btn:hover {
            transform: translateY(-1px);
        }

        /* --- 横屏手机: 紧凑设置面板 --- */
        @media (max-height: 520px) and (max-width: 1024px) {
            .settings-content {
                width: 70vw;
                max-width: 480px;
                max-height: 70vh;
                padding: 12px 16px;
            }

            #settings-panel h3 {
                font-size: 14px;
                margin-bottom: 6px;
            }

            #settings-panel label {
                font-size: 12px;
                margin-top: 8px;
            }

            #apply-settings {
                margin: 8px 0 10px 0;
                padding: 8px 0;
            }
        }

        @keyframes popUp {
            0% { opacity: 0; transform: translateY(0) scale(0.5); }
            50% { opacity: 1; transform: translateY(-30px) scale(1.2); }
            100% { opacity: 0; transform: translateY(-50px) scale(1); }
        }
    </style>
</head>
<body>

<div id="ui-shell">
    <div id="action-stack">
        <a id="back-home-btn" href="../index.html">← 返回主页</a>
        <button id="settings-toggle">⚙ 设置</button>
    </div>
</div>

<div id="ui-layer">
    <!-- UI 元素直接绘制在 Canvas 上以提高性能 -->
</div>

<div id="settings-panel">
    <div class="settings-content">
        <h3>游戏设置 <button id="close-settings">×</button></h3>

        <button id="apply-settings">应用并重新开局</button>

        <label>球半径 <span id="ball-size-display">10px</span></label>
        <div class="spin-row">
            <button class="spin-btn" data-target="ball-size-input" data-step="1" data-min="6" data-max="100">−</button>
            <input type="range" min="6" max="100" step="1" id="ball-size-input" value="10">
            <button class="spin-btn" data-target="ball-size-input" data-step="1" data-min="6" data-max="100">+</button>
        </div>
        
        <label>袋口大小 <span id="pocket-size-display">22px</span></label>
        <div class="spin-row">
            <button class="spin-btn" data-target="pocket-size-input" data-step="2" data-min="10" data-max="200">−</button>
            <input type="range" min="10" max="200" step="1" id="pocket-size-input" value="22">
            <button class="spin-btn" data-target="pocket-size-input" data-step="2" data-min="10" data-max="200">+</button>
        </div>

        <label>最大击球力度 <span id="power-max-display">200</span></label>
        <div class="spin-row">
            <button class="spin-btn" data-target="power-max-input" data-step="20" data-min="80" data-max="10000">−</button>
            <input type="range" min="80" max="10000" step="10" id="power-max-input" value="200">
            <button class="spin-btn" data-target="power-max-input" data-step="20" data-min="80" data-max="10000">+</button>
        </div>

        <label>桌台摩擦力 <span id="friction-display">0.988</span></label>
        <div class="spin-row">
            <button class="spin-btn" data-target="friction-input" data-step="0.01" data-min="0" data-max="1">−</button>
            <input type="range" min="0" max="1" step="0.001" id="friction-input" value="0.988">
            <button class="spin-btn" data-target="friction-input" data-step="0.01" data-min="0" data-max="1">+</button>
        </div>

        <div class="select-row">
            <label for="aim-mode-select">瞄准辅助</label>
            <select id="aim-mode-select">
                <option value="cue">仅球杆方向</option>
                <option value="basic" selected>基础引导线</option>
                <option value="advanced">高级引导线 (反弹预测)</option>
                <option value="offline">离线模拟 (全路径预测)</option>
            </select>
        </div>
        
        <label>桌呢配色</label>
        <select id="felt-select">
            <option value="midnight">午夜蓝 (Midnight)</option>
            <option value="classic">经典绿 (Classic)</option>
            <option value="ember">余烬红 (Ember)</option>
            <option value="aurora">极光青 (Aurora)</option>
            <option value="metal_steel">金属钢 (Steel)</option>
            <option value="metal_gold">金属金 (Gold)</option>
            <option value="metal_copper">金属铜 (Copper)</option>
            <option value="diamond_cyan">青钻 (Cyan Diamond)</option>
            <option value="diamond_violet">紫钻 (Violet Diamond)</option>
            <option value="plastic_blue">塑胶蓝 (Blue Plastic)</option>
            <option value="plastic_red">塑胶红 (Red Plastic)</option>
            <option value="stone_marble">大理石 (Marble)</option>
            <option value="stone_slate">板岩 (Slate)</option>
        </select>

        <label>球材质</label>
        <select id="ball-material-select">
            <option value="classic">经典树脂</option>
            <option value="metal_steel">钢制金属</option>
            <option value="metal_gold">黄金金属</option>
            <option value="metal_copper">红铜金属</option>
            <option value="diamond_cyan">青色晶体</option>
            <option value="diamond_violet">紫色晶体</option>
            <option value="plastic_blue">蓝色塑料</option>
            <option value="plastic_red">红色塑料</option>
            <option value="stone_marble">大理石纹</option>
            <option value="stone_slate">板岩纹路</option>
        </select>
    </div>
</div>

<div id="ball-hand-banner">自由球 — 拖动白球放置</div>

<div id="end-screen">
    <div class="end-content">
        <h2 id="end-message">本局结束</h2>
        <button id="restart-btn">开始新的一局</button>
    </div>
</div>

<!-- 移动端微调控制 -->
<div id="mobile-controls">
    <div class="fine-tune-btn" id="btn-left">↺</div>
    <div class="fine-tune-btn" id="btn-right">↻</div>
</div>

<!-- 移动端确认击球按钮 (仅在离线模拟模式下可见) -->
<button id="confirm-shot-btn" style="display: none;">击球</button>

<!-- 桌面端操作提示 -->
<div id="desktop-hint">
    使用 <span class="key-badge">←</span> <span class="key-badge">→</span> 瞄准 &nbsp;|&nbsp; 按住 <span class="key-badge">空格</span> 击球
</div>

<div id="game-toast"></div>
<canvas id="gameCanvas"></canvas>

<script>
// --- 配置参数 ---
const CONFIG = {
    BALL_RADIUS: 10,
    POCKET_RADIUS: 22,
    CUSHION_SIZE: 20,
    FRICTION: 0.988,
    WALL_BOUNCE: 0.75,
    BALL_BOUNCE: 0.94,
    MAX_POWER: 200,
    POWER_SCALE: 0.14,
    STOP_VELOCITY: 0.05,
    TRAIL_FADE: 0.07,
    AIM_SENSITIVITY_TOUCH: 0.005,
    AIM_SENSITIVITY_KEY: 0.01
};

const TYPE = { CUE: 0, SOLID: 1, STRIPE: 2, BLACK: 3 };
const PALETTE = {
    BG: '#050505',
    FELT: ['#0b4d0b', '#062b06'], // 默认：经典绿
    P1_COLOR: '#4facfe',
    P2_COLOR: '#f093fb',
    SOLIDS: ['#FFD700', '#FF6B6B', '#4ECDC4', '#1A535C', '#FF9F1C', '#2E86AB', '#8D99AE'],
    STRIPES: ['#FFE66D', '#FF8C94', '#96CEB4', '#45B8AC', '#FFAD60', '#5DADE2', '#A3E4D7']
};

const BASE_CONFIG = {
    BALL_RADIUS: CONFIG.BALL_RADIUS,
    POCKET_RADIUS: CONFIG.POCKET_RADIUS,
    POWER_SCALE: CONFIG.POWER_SCALE,
    MAX_POWER: CONFIG.MAX_POWER,
    FRICTION: CONFIG.FRICTION
};

const SETTINGS = {
    ballRadius: CONFIG.BALL_RADIUS,
    pocketRadius: CONFIG.POCKET_RADIUS,
    feltScheme: 'classic',
    maxPower: CONFIG.MAX_POWER,
    friction: CONFIG.FRICTION,
    ballMaterial: 'classic',
    aimMode: 'basic' // 'cue' | 'basic' | 'advanced' | 'offline'
};

const FELT_SCHEMES = {
    midnight: ['#001a33', '#000814'],
    classic: ['#0b4d0b', '#062b06'],
    ember: ['#331111', '#120505'],
    aurora: ['#002b36', '#00111b'],
    metal_steel: ['#3a3f4a', '#16181e'],
    metal_gold: ['#b88a1a', '#3c2604'],
    metal_copper: ['#b45b33', '#34150d'],
    diamond_cyan: ['#0c3b52', '#010b16'],
    diamond_violet: ['#34154f', '#05020d'],
    plastic_blue: ['#004b8d', '#02111f'],
    plastic_red: ['#7b1616', '#250202'],
    stone_marble: ['#e5e5e5', '#9e9e9e'],
    stone_slate: ['#3b3e46', '#14161a']
};

const STATE = {
    turn: 1,
    assigned: false,
    p1Group: null,
    aimAngle: Math.PI/2,
    power: 0,
    isCharging: false,
    spaceCharging: false, // 键盘蓄力标志
    spaceChargeDir: 1,    // 切换蓄力方向
    sunkThisTurn: [],
    foul: false,
    gameOver: false,
    canShoot: true,
    inputType: 'unknown', // 'mouse' or 'touch'
    shotCount: 0,         // 本局总杆数
    scores: {1: 0, 2: 0},
    ballInHand: false,
    ballMaterial: 'classic',
    aimMode: 'basic',
    pendingShot: false, // 离线模式：等待确认
    savedPower: 0 // pendingShot 时的保存力度
};

class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vector(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() { let m = this.mag(); return m === 0 ? new Vector(0,0) : new Vector(this.x / m, this.y / m); }
    dist(v) { return Math.sqrt((this.x - v.x) ** 2 + (this.y - v.y) ** 2); }
    
    // 点积辅助函数
    static dot(v1, v2) { return v1.x * v2.x + v1.y * v2.y; }
}

class Ball {
    constructor(x, y, type, color, id) {
        this.pos = new Vector(x, y);
        this.vel = new Vector(0, 0);
        this.type = type;
        this.color = color;
        this.id = id;
        this.active = true;
    }

    update(skipTrail = false) {
        if (!this.active) return;
        if (!skipTrail && this.vel.mag() > 1) {
            trailCtx.beginPath();
            if (this.type === TYPE.SOLID || this.type === TYPE.BLACK || this.type === TYPE.CUE) {
                trailCtx.arc(this.pos.x, this.pos.y, CONFIG.BALL_RADIUS * 0.8, 0, Math.PI * 2);
                trailCtx.fillStyle = this.type === TYPE.CUE ? 'rgba(255,255,255,0.2)' : this.color;
                trailCtx.fill();
            } else {
                trailCtx.arc(this.pos.x, this.pos.y, CONFIG.BALL_RADIUS * 0.6, 0, Math.PI * 2);
                trailCtx.fillStyle = this.color;
                trailCtx.globalAlpha = 0.4;
                trailCtx.fill();
                trailCtx.globalAlpha = 1.0;
            }
        }
        this.pos = this.pos.add(this.vel);
        this.vel = this.vel.mult(CONFIG.FRICTION);
        if (this.vel.mag() < CONFIG.STOP_VELOCITY) this.vel = new Vector(0, 0);

        const bound = CONFIG.CUSHION_SIZE + CONFIG.BALL_RADIUS;
        if (this.pos.x < bound) { this.pos.x = bound; this.vel.x *= -CONFIG.WALL_BOUNCE; }
        if (this.pos.x > logicalWidth - bound) { this.pos.x = logicalWidth - bound; this.vel.x *= -CONFIG.WALL_BOUNCE; }
        if (this.pos.y < bound) { this.pos.y = bound; this.vel.y *= -CONFIG.WALL_BOUNCE; }
        if (this.pos.y > logicalHeight - bound) { this.pos.y = logicalHeight - bound; this.vel.y *= -CONFIG.WALL_BOUNCE; }
    }

    draw(ctx) {
        if (!this.active) return;
        const x = this.pos.x;
        const y = this.pos.y;
        const r = CONFIG.BALL_RADIUS;
        const material = STATE.ballMaterial || 'classic';

        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.beginPath(); ctx.arc(x + r*0.3, y + r*0.3, r, 0, Math.PI * 2); ctx.fill();

        // 绘制母球
        if (this.type === TYPE.CUE) {
            if (material.startsWith('metal_')) {
                // 金属
                let grad = ctx.createRadialGradient(x-r*0.4, y-r*0.4, r*0.2, x, y, r);
                grad.addColorStop(0, '#ffffff');
                grad.addColorStop(0.4, '#d0d0d0');
                grad.addColorStop(1, '#7f7f7f');
                ctx.fillStyle = grad;
            } else if (material.startsWith('diamond_')) {
                // 钻石
                let grad = ctx.createRadialGradient(x-r*0.5, y-r*0.5, r*0.1, x, y, r);
                grad.addColorStop(0, 'rgba(255,255,255,0.9)');
                grad.addColorStop(0.4, 'rgba(230,230,255,0.7)');
                grad.addColorStop(1, 'rgba(180,190,255,0.2)');
                ctx.fillStyle = grad;
            } else if (material.startsWith('stone_')) {
                // 石头
                let grad = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.2, x, y, r);
                grad.addColorStop(0, '#e0e0e0');
                grad.addColorStop(1, '#8b8b8b');
                ctx.fillStyle = grad;
            } else {
                // 经典/塑料
            let grad = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.2, x, y, r);
            grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#ccc');
                ctx.fillStyle = grad;
            }
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            return;
        }

        // 材质辅助函数
        const drawSolidClassic = () => {
            let grad = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.2, x, y, r);
            grad.addColorStop(0, adjustBrightness(this.color, 60));
            grad.addColorStop(0.3, this.color);
            grad.addColorStop(1, adjustBrightness(this.color, -50));
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
        };
        const drawStripeClassic = () => {
            // 深色基底
            ctx.fillStyle = "#111";
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            // 中间色带
            ctx.save();
            ctx.beginPath();
            ctx.rect(x - r, y - r*0.45, r*2, r*0.9);
            ctx.clip();
            let bandGrad = ctx.createLinearGradient(x - r, y, x + r, y);
            bandGrad.addColorStop(0, adjustBrightness(this.color, 40));
            bandGrad.addColorStop(0.5, this.color);
            bandGrad.addColorStop(1, adjustBrightness(this.color, -20));
            ctx.fillStyle = bandGrad;
            ctx.beginPath(); ctx.arc(x, y, r*0.95, 0, Math.PI*2); ctx.fill();
            ctx.restore();
            // 细微反光
            let glare = ctx.createLinearGradient(x-r, y-r, x+r, y+r);
            glare.addColorStop(0, "rgba(255,255,255,0.4)"); glare.addColorStop(0.5, "rgba(255,255,255,0)");
            ctx.fillStyle = glare; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
        };

        const drawMetal = () => {
            let base = this.type === TYPE.BLACK ? '#222' : this.color;
            let grad = ctx.createLinearGradient(x-r, y-r, x+r, y+r);
            grad.addColorStop(0, adjustBrightness(base, 60));
            grad.addColorStop(0.25, base);
            grad.addColorStop(0.5, adjustBrightness(base, -20));
            grad.addColorStop(0.75, adjustBrightness(base, 40));
            grad.addColorStop(1, adjustBrightness(base, -40));
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            // 高光
            ctx.strokeStyle = "rgba(255,255,255,0.6)";
            ctx.lineWidth = r * 0.18;
            ctx.beginPath();
            ctx.arc(x, y, r*0.65, -0.6, 0.4);
            ctx.stroke();
        };

        const drawDiamond = () => {
            let grad = ctx.createRadialGradient(x-r*0.4, y-r*0.4, r*0.1, x, y, r);
            grad.addColorStop(0, "rgba(255,255,255,0.95)");
            grad.addColorStop(0.3, adjustBrightness(this.color, 40));
            grad.addColorStop(0.7, this.color);
            grad.addColorStop(1, "rgba(10,10,20,0.9)");
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            // 切面线条
            ctx.strokeStyle = "rgba(255,255,255,0.4)";
            ctx.lineWidth = 0.7;
            ctx.beginPath();
            ctx.moveTo(x-r*0.3, y);
            ctx.lineTo(x, y-r*0.4);
            ctx.lineTo(x+r*0.3, y);
            ctx.lineTo(x, y+r*0.4);
            ctx.closePath();
            ctx.stroke();
        };

        const drawStone = () => {
            let base = this.type === TYPE.BLACK ? '#1a1a1a' : this.color;
            let grad = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.2, x, y, r);
            grad.addColorStop(0, adjustBrightness(base, 30));
            grad.addColorStop(1, adjustBrightness(base, -30));
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            // 斑点效果
            ctx.fillStyle = "rgba(255,255,255,0.15)";
            for (let i = 0; i < 6; i++) {
                let angle = Math.random() * Math.PI * 2;
                let rr = Math.random() * r*0.7;
                ctx.beginPath();
                ctx.arc(x + Math.cos(angle)*rr, y + Math.sin(angle)*rr, r*0.1, 0, Math.PI*2);
                ctx.fill();
            }
        };

        if (this.type === TYPE.BLACK) {
            if (material.startsWith('metal_')) {
                drawMetal();
            } else if (material.startsWith('diamond_')) {
                // 黑钻
                let grad = ctx.createRadialGradient(x-r*0.4, y-r*0.4, r*0.1, x, y, r);
                grad.addColorStop(0, "rgba(255,255,255,0.8)");
                grad.addColorStop(0.3, "#444");
                grad.addColorStop(1, "#000");
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            } else if (material.startsWith('stone_')) {
                drawStone();
            } else {
            let grad = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.2, x, y, r);
            grad.addColorStop(0, '#444'); grad.addColorStop(1, '#000');
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            }
            // 8号字样
            ctx.fillStyle = "#fff"; ctx.font = "bold 10px Inter";
            ctx.textAlign = "center"; ctx.textBaseline="middle"; ctx.fillText("8", x, y+0.5);
        } else if (this.type === TYPE.SOLID) {
            if (material.startsWith('metal_')) {
                drawMetal();
            } else if (material.startsWith('diamond_')) {
                drawDiamond();
            } else if (material.startsWith('stone_')) {
                drawStone();
            } else {
                drawSolidClassic();
            }
        } else if (this.type === TYPE.STRIPE) {
            if (material.startsWith('metal_')) {
                // 金属条纹
                ctx.fillStyle = "#050509"; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
                ctx.save();
                ctx.beginPath();
                ctx.rect(x - r, y - r*0.45, r*2, r*0.9);
                ctx.clip();
                let bandGrad = ctx.createLinearGradient(x - r, y, x + r, y);
                bandGrad.addColorStop(0, adjustBrightness(this.color, 50));
                bandGrad.addColorStop(0.5, this.color);
                bandGrad.addColorStop(1, adjustBrightness(this.color, -10));
                ctx.fillStyle = bandGrad;
                ctx.beginPath(); ctx.arc(x, y, r*0.96, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            let glare = ctx.createLinearGradient(x-r, y-r, x+r, y+r);
                glare.addColorStop(0, "rgba(255,255,255,0.55)"); glare.addColorStop(0.5, "rgba(255,255,255,0)");
            ctx.fillStyle = glare; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            } else if (material.startsWith('diamond_')) {
                // 钻石条纹
                ctx.fillStyle = "rgba(8,8,18,0.98)"; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
                ctx.save();
                ctx.beginPath();
                ctx.rect(x - r, y - r*0.45, r*2, r*0.9);
                ctx.clip();
                let bandGrad = ctx.createLinearGradient(x - r, y, x + r, y);
                bandGrad.addColorStop(0, "rgba(255,255,255,0.9)");
                bandGrad.addColorStop(0.4, adjustBrightness(this.color, 40));
                bandGrad.addColorStop(1, this.color);
                ctx.fillStyle = bandGrad;
                ctx.beginPath(); ctx.arc(x, y, r*0.95, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            } else if (material.startsWith('stone_')) {
                // 石头条纹
                drawStone();
                ctx.save();
                ctx.beginPath();
                ctx.rect(x - r, y - r*0.4, r*2, r*0.8);
                ctx.clip();
                ctx.fillStyle = adjustBrightness(this.color, 20);
                ctx.globalAlpha = 0.7;
                ctx.beginPath(); ctx.arc(x, y, r*0.9, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            } else {
                drawStripeClassic();
            }
        }
    }
}

// --- 全局变量 ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const trailCanvas = document.createElement('canvas');
const trailCtx = trailCanvas.getContext('2d');

const uiPowerControl = document.getElementById('power-control');
const uiPowerFill = document.getElementById('power-fill');
const uiPowerHandle = document.getElementById('power-handle');
const uiToast = document.getElementById('game-toast');
const uiMobileControls = document.getElementById('mobile-controls');
const uiDesktopHint = document.getElementById('desktop-hint');
const uiSettingsToggle = document.getElementById('settings-toggle');
const uiSettingsPanel = document.getElementById('settings-panel');
const uiCloseSettings = document.getElementById('close-settings');
const uiBallRange = document.getElementById('ball-size-input');
const uiPocketRange = document.getElementById('pocket-size-input');
const uiFeltSelect = document.getElementById('felt-select');
const uiApplySettings = document.getElementById('apply-settings');
const uiBallDisplay = document.getElementById('ball-size-display');
const uiPocketDisplay = document.getElementById('pocket-size-display');
const uiPowerMaxRange = document.getElementById('power-max-input');
const uiPowerMaxDisplay = document.getElementById('power-max-display');
const uiFrictionRange = document.getElementById('friction-input');
const uiFrictionDisplay = document.getElementById('friction-display');
const uiBallHandBanner = document.getElementById('ball-hand-banner');
const uiEndScreen = document.getElementById('end-screen');
const uiEndMessage = document.getElementById('end-message');
const uiRestartBtn = document.getElementById('restart-btn');
const uiBallMaterialSelect = document.getElementById('ball-material-select');
const uiAimModeSelect = document.getElementById('aim-mode-select');
const uiConfirmShotBtn = document.getElementById('confirm-shot-btn');

if (uiRestartBtn) {
    uiRestartBtn.addEventListener('click', () => {
        hideEndScreen();
        resetGame();
    });
}

let logicalWidth, logicalHeight;
let balls = [];
let pockets = [];
let whiteBall;
let aimTouchStart = null;
let aimAngleStart = 0;
let placingBall = false;
let lastPlacementValid = false;

// --- 初始化 ---
function resize() {
    const dpr = window.devicePixelRatio || 1;
    logicalWidth = window.innerWidth;
    logicalHeight = window.innerHeight;
    canvas.width = logicalWidth * dpr; canvas.height = logicalHeight * dpr;
    canvas.style.width = logicalWidth + "px"; canvas.style.height = logicalHeight + "px";
    ctx.resetTransform(); ctx.scale(dpr, dpr);
    trailCanvas.width = logicalWidth * dpr; trailCanvas.height = logicalHeight * dpr;
    trailCtx.resetTransform(); trailCtx.scale(dpr, dpr);
    const off = CONFIG.CUSHION_SIZE * 0.8;
    pockets = [
        new Vector(off, off), new Vector(logicalWidth/2, off-4), new Vector(logicalWidth-off, off),
        new Vector(off, logicalHeight-off), new Vector(logicalWidth/2, logicalHeight-off+4), new Vector(logicalWidth-off, logicalHeight-off)
    ];
}

function init() {
    resize();
    window.addEventListener('resize', resize);
    resetGame();
    setupInputs();
    setupSettingsPanel();
    requestAnimationFrame(loop);
}

function isInPowerBarArea(pos) {
    const c = CONFIG.CUSHION_SIZE;
    const barWidth = c;
    return pos.x >= logicalWidth - barWidth && pos.x <= logicalWidth &&
           pos.y >= c && pos.y <= logicalHeight - c;
}

function setupInputs() {
    // 触摸/鼠标输入：根据位置判断是瞄准还是调整力度
    canvas.addEventListener('touchstart', e => {
        STATE.inputType = 'touch'; updateDeviceUI();
        const pos = getEventPos(e);
        if (isInPowerBarArea(pos)) {
            handlePowerStart(e);
        } else {
        handleAimStart(e);
        }
    }, {passive: false});
    window.addEventListener('touchmove', e => {
        if (STATE.isCharging) {
            handlePowerMove(e);
        } else {
            handleAimMove(e);
        }
    }, {passive: false});
    
    // 鼠标输入
    canvas.addEventListener('mousedown', e => {
        STATE.inputType = 'mouse'; updateDeviceUI();
        const pos = getEventPos(e);
        if (isInPowerBarArea(pos)) {
            handlePowerStart(e);
        } else {
        handleAimStart(e);
        }
    });
    window.addEventListener('mousemove', e => {
        STATE.inputType = 'mouse'; updateDeviceUI();
        if (STATE.isCharging) {
            handlePowerMove(e);
        } else {
        handleAimMove(e);
        }
    });

    // 移动端微调按钮
    const btnLeft = document.getElementById('btn-left');
    const btnRight = document.getElementById('btn-right');
    const fineTune = (dir) => {
        if(!STATE.canShoot) return;
        STATE.aimAngle += dir * 0.005; // 微调步进
        if(navigator.vibrate) navigator.vibrate(5);
    };
    btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); fineTune(-1); });
    btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); fineTune(1); });
    
    btnLeft.addEventListener('mousedown', (e) => { e.preventDefault(); fineTune(-1); });
    btnRight.addEventListener('mousedown', (e) => { e.preventDefault(); fineTune(1); });

    window.addEventListener('mouseup', handlePowerEnd);
    window.addEventListener('mouseup', handlePlacementEnd);
    window.addEventListener('touchend', handlePowerEnd);
    window.addEventListener('touchend', handlePlacementEnd);

    // 键盘控制
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    window.addEventListener('wheel', handleWheel);

    // 确认击球按钮 (移动端离线模式)
    if (uiConfirmShotBtn) {
        let touchStartedOnButton = false;
        
        uiConfirmShotBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            touchStartedOnButton = true;
        }, {passive: false});
        
        uiConfirmShotBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (touchStartedOnButton) {
                touchStartedOnButton = false;
                confirmShot();
            }
        }, {passive: false});
        
        uiConfirmShotBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            confirmShot();
        });
    }
}

function setupSettingsPanel() {
    if (!uiSettingsToggle) return;
    uiBallRange.value = CONFIG.BALL_RADIUS;
    uiPocketRange.value = CONFIG.POCKET_RADIUS;
    uiBallDisplay.innerText = `${CONFIG.BALL_RADIUS}px`;
    uiPocketDisplay.innerText = `${CONFIG.POCKET_RADIUS}px`;
    uiFeltSelect.value = SETTINGS.feltScheme;
    if (uiBallMaterialSelect) uiBallMaterialSelect.value = SETTINGS.ballMaterial;
    uiPowerMaxRange.value = CONFIG.MAX_POWER;
    uiPowerMaxDisplay.innerText = `${CONFIG.MAX_POWER}`;
    uiFrictionRange.value = CONFIG.FRICTION.toFixed(3);
    uiFrictionDisplay.innerText = CONFIG.FRICTION.toFixed(3);
    if (uiAimModeSelect) uiAimModeSelect.value = SETTINGS.aimMode || 'basic';

    const togglePanel = (show) => {
        uiSettingsPanel.classList[show ? 'add' : 'remove']('visible');
    };

    uiSettingsToggle.addEventListener('click', () => togglePanel(!uiSettingsPanel.classList.contains('visible')));
    uiCloseSettings.addEventListener('click', () => togglePanel(false));

    uiBallRange.addEventListener('input', () => {
        SETTINGS.ballRadius = Number(uiBallRange.value);
        uiBallDisplay.innerText = `${SETTINGS.ballRadius}px`;
    });
    uiPocketRange.addEventListener('input', () => {
        SETTINGS.pocketRadius = Number(uiPocketRange.value);
        uiPocketDisplay.innerText = `${SETTINGS.pocketRadius}px`;
    });
    uiFeltSelect.addEventListener('change', () => {
        SETTINGS.feltScheme = uiFeltSelect.value;
    });
    if (uiBallMaterialSelect) {
        uiBallMaterialSelect.addEventListener('change', () => {
            SETTINGS.ballMaterial = uiBallMaterialSelect.value;
        });
    }
    uiPowerMaxRange.addEventListener('input', () => {
        SETTINGS.maxPower = Number(uiPowerMaxRange.value);
        uiPowerMaxDisplay.innerText = `${SETTINGS.maxPower}`;
    });
    uiFrictionRange.addEventListener('input', () => {
        SETTINGS.friction = Number(uiFrictionRange.value);
        uiFrictionDisplay.innerText = SETTINGS.friction.toFixed(3);
    });

    if (uiAimModeSelect) {
        uiAimModeSelect.addEventListener('change', () => {
            SETTINGS.aimMode = uiAimModeSelect.value;
        });
    }

    // +/- 按钮控制
    const spinButtons = document.querySelectorAll('.spin-btn');
    spinButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.preventDefault();
            const targetId = btn.getAttribute('data-target');
            const step = Number(btn.getAttribute('data-step') || '1');
            const min = Number(btn.getAttribute('data-min') || '-999999');
            const max = Number(btn.getAttribute('data-max') || '999999');
            const dir = btn.textContent.trim() === '+' ? 1 : -1;
            const input = document.getElementById(targetId);
            if (!input) return;
            let current = Number(input.value || input.getAttribute('value') || 0);
            if (isNaN(current)) current = 0;
            let next = current + dir * step;
            if (next < min) next = min;
            if (next > max) next = max;
            input.value = String(next);
            const ev = new Event('input', { bubbles: true });
            input.dispatchEvent(ev);
        });
    });

    uiApplySettings.addEventListener('click', () => {
        applyCustomSettings();
        togglePanel(false);
    });
}

function applyCustomSettings() {
    CONFIG.BALL_RADIUS = SETTINGS.ballRadius;
    CONFIG.POCKET_RADIUS = SETTINGS.pocketRadius;
    PALETTE.FELT = FELT_SCHEMES[SETTINGS.feltScheme] || FELT_SCHEMES.midnight;
    CONFIG.POWER_SCALE = BASE_CONFIG.POWER_SCALE * (BASE_CONFIG.BALL_RADIUS / CONFIG.BALL_RADIUS);
    CONFIG.MAX_POWER = SETTINGS.maxPower;
    CONFIG.FRICTION = SETTINGS.friction;
    STATE.ballMaterial = SETTINGS.ballMaterial || 'classic';
    STATE.aimMode = SETTINGS.aimMode || 'basic';
    STATE.pendingShot = false;
    updateConfirmButton();
    showToast("设置已应用 — 已重置球局");
    resetGame();
}

function updateDeviceUI() {
    if (STATE.inputType === 'touch') {
        uiMobileControls.style.display = 'flex';
        uiDesktopHint.style.display = 'none';
    } else {
        uiMobileControls.style.display = 'none';
        uiDesktopHint.style.display = 'block';
    }
    updateConfirmButton();
}

function updateConfirmButton() {
    if (!uiConfirmShotBtn) return;
    const showBtn = STATE.aimMode === 'offline' && 
                    STATE.inputType === 'touch' && 
                    STATE.pendingShot && 
                    STATE.canShoot && 
                    !STATE.gameOver;
    uiConfirmShotBtn.style.display = showBtn ? 'block' : 'none';
    uiConfirmShotBtn.disabled = !STATE.pendingShot;
}

function confirmShot() {
    const buttonVisible = uiConfirmShotBtn && uiConfirmShotBtn.style.display !== 'none' && !uiConfirmShotBtn.disabled;
    
    if (!buttonVisible && !STATE.pendingShot) return;
    if (!STATE.canShoot) return;
    if (STATE.gameOver) return;
    if (STATE.ballInHand) return;
    
    STATE.pendingShot = false;
    
    // 使用保存的力度或当前力度
    const shotPower = Math.max(0.1, STATE.savedPower || STATE.power || 0.1);
    
    const originalPower = STATE.power;
    STATE.power = shotPower;
    
    if (uiConfirmShotBtn) {
        uiConfirmShotBtn.style.display = 'none';
        uiConfirmShotBtn.disabled = true;
        uiConfirmShotBtn.blur();
    }
    
    shoot();
    
    STATE.savedPower = 0;
    STATE.power = 0;
    updatePowerUI(0);
    updateConfirmButton();
}

// --- 输入处理 ---
function handleAimStart(e) {
    if (STATE.gameOver) return;
    
    if (e.target === uiConfirmShotBtn || (e.target && e.target.closest && e.target.closest('#confirm-shot-btn'))) {
        return;
    }
    
    if (STATE.ballInHand && STATE.canShoot) {
        e.preventDefault();
        placingBall = true;
        attemptPlaceCueBall(getEventPos(e));
        return;
    }
    
    // 离线模式桌面端：如果有待确认的击球，点击鼠标左键确认
    if (STATE.aimMode === 'offline' && STATE.inputType === 'mouse' && STATE.pendingShot && e.button === 0) {
        e.preventDefault();
        confirmShot();
        return;
    }
    
    if (!STATE.canShoot || STATE.spaceCharging) return;
    if (e.target !== canvas) return;
    e.preventDefault();
    aimTouchStart = getEventPos(e);
    aimAngleStart = STATE.aimAngle;
}

function handleAimMove(e) {
    if (STATE.gameOver) return;
    if (STATE.ballInHand && placingBall) {
        e.preventDefault();
        attemptPlaceCueBall(getEventPos(e));
        return;
    }
    
    if (STATE.aimMode === 'offline' && STATE.pendingShot && STATE.inputType === 'mouse') {
        // 允许在待确认时微调瞄准
    } else if (!STATE.canShoot || STATE.isCharging || STATE.spaceCharging) {
        return;
    }
    const pos = getEventPos(e);

    if (STATE.inputType === 'mouse') {
        const angle = Math.atan2(pos.y - whiteBall.pos.y, pos.x - whiteBall.pos.x);
        if (!isNaN(angle)) STATE.aimAngle = angle;
        return;
    }

    if (!aimTouchStart) return;
    let dy = pos.y - aimTouchStart.y;
    let sensitivity = CONFIG.AIM_SENSITIVITY_TOUCH;
    STATE.aimAngle = aimAngleStart + (dy * sensitivity); 
}

function handleKeyDown(e) {
    if (!STATE.canShoot || STATE.gameOver) return;
    STATE.inputType = 'mouse'; updateDeviceUI();
    
    const step = e.shiftKey ? 0.05 : 0.005;

    if (e.code === 'ArrowLeft') STATE.aimAngle -= step;
    if (e.code === 'ArrowRight') STATE.aimAngle += step;
    
    if (e.code === 'Space' && !STATE.spaceCharging && !e.repeat) {
        if (STATE.aimMode === 'offline' && STATE.pendingShot) {
            STATE.pendingShot = false;
            updateConfirmButton();
        }
        STATE.spaceCharging = true;
        if (STATE.aimMode !== 'offline') {
        STATE.power = 0;
        }
        STATE.spaceChargeDir = (STATE.power > 0.5) ? -1 : 1;
    }
}

function handleKeyUp(e) {
    if (STATE.gameOver) return;
    if (e.code === 'Space' && STATE.spaceCharging) {
        STATE.spaceCharging = false;
        
        if (STATE.aimMode === 'offline') {
            if (STATE.power > 0.1) {
                STATE.pendingShot = true;
                STATE.savedPower = STATE.power;
            } else {
                STATE.power = 0;
                STATE.savedPower = 0;
                updatePowerUI(0);
            }
        } else {
        shoot();
        STATE.power = 0;
        updatePowerUI(0);
        }
    }
}

function handleWheel(e) {
    if (!STATE.canShoot || STATE.ballInHand || STATE.gameOver) return;
    STATE.aimAngle += e.deltaY * 0.0001; 
}

// 力度条逻辑
function handlePowerStart(e) {
    if (!STATE.canShoot || STATE.spaceCharging || STATE.ballInHand || STATE.gameOver) return;
    e.preventDefault();
    if (STATE.aimMode === 'offline' && STATE.pendingShot) {
        STATE.pendingShot = false;
        updateConfirmButton();
    }
    STATE.isCharging = true;
    updatePowerUI(0);
}

function handlePowerMove(e) {
    if (!STATE.isCharging) return;
    const pos = getEventPos(e);
    const c = CONFIG.CUSHION_SIZE;
    const top = c;
    const bottom = logicalHeight - c;
    // 右侧库边力度条
    let t = (bottom - pos.y) / (bottom - top);
    let percent = Math.max(0, Math.min(1, t));
    STATE.power = percent;
    updatePowerUI(percent);
}

function handlePowerEnd(e) {
    if (!STATE.isCharging) return;
    STATE.isCharging = false;
    
    if (STATE.aimMode === 'offline') {
        if (STATE.power > 0.1) {
            STATE.pendingShot = true;
            STATE.savedPower = STATE.power;
            updateConfirmButton();
        } else {
            STATE.power = 0;
            STATE.savedPower = 0;
            updatePowerUI(0);
        }
    } else {
        if (STATE.power > 0.1) shoot();
        STATE.power = 0;
        updatePowerUI(0);
    }
}

function getEventPos(e) {
    if (e.touches && e.touches.length > 0) return new Vector(e.touches[0].clientX, e.touches[0].clientY);
    return new Vector(e.clientX, e.clientY);
}

function clampToTableBounds(pos) {
    const bound = CONFIG.CUSHION_SIZE + CONFIG.BALL_RADIUS;
    const x = Math.max(bound, Math.min(logicalWidth - bound, pos.x));
    const y = Math.max(bound, Math.min(logicalHeight - bound, pos.y));
    return new Vector(x, y);
}

function isPlacementValid(pos) {
    for (let b of balls) {
        if (b === whiteBall || !b.active) continue;
        if (pos.dist(b.pos) < CONFIG.BALL_RADIUS * 2) return false;
    }
    return true;
}

function attemptPlaceCueBall(rawPos) {
    if (!rawPos) return false;
    const bounded = clampToTableBounds(rawPos);
    if (!isPlacementValid(bounded)) {
        if (!placingBall) showToast("白球位置重叠");
        lastPlacementValid = false;
        return false;
    }
    whiteBall.active = true;
    whiteBall.pos = bounded;
    whiteBall.vel = new Vector(0,0);
    lastPlacementValid = true;
    return true;
}

function handlePlacementEnd() {
    if (!STATE.ballInHand || !placingBall) return;
    placingBall = false;
    if (lastPlacementValid) {
        STATE.ballInHand = false;
        updateBallInHandBanner();
        showToast("白球已放置");
    } else {
        updateBallInHandBanner();
        showToast("请选择合法位置");
    }
}

// --- 游戏逻辑 ---
function updatePowerUI(percent) {
    // 绘制在 Canvas 上
}

function computeShotVelocity(dir, power) {
    const clamped = Math.max(0, Math.min(1, power || 0));
    const force = clamped * CONFIG.MAX_POWER;
    return dir.mult(force * CONFIG.POWER_SCALE);
}

function shoot() {
    if (STATE.ballInHand || STATE.gameOver) return;
    hideToast();
    STATE.shotCount += 1;
    STATE.canShoot = false;
    const dir = new Vector(Math.cos(STATE.aimAngle), Math.sin(STATE.aimAngle));
    whiteBall.vel = computeShotVelocity(dir, STATE.power);
    STATE.sunkThisTurn = [];
    STATE.foul = false;
    if(navigator.vibrate) try { navigator.vibrate(20); } catch(e){}
}

function resetGame() {
    hideEndScreen();
    hideToast();
    balls = [];
    STATE.turn = 1; STATE.assigned = false; STATE.p1Group = null;
    STATE.foul = false; STATE.gameOver = false; STATE.sunkThisTurn = [];
    STATE.canShoot = true;
    STATE.ballInHand = false; placingBall = false; lastPlacementValid = false;
    STATE.scores = {1: 0, 2: 0};
    STATE.shotCount = 0;
    STATE.power = 0;
    STATE.isCharging = false;
    STATE.spaceCharging = false;
    STATE.spaceChargeDir = 1;
    STATE.inputType = 'unknown';
    STATE.pendingShot = false;
    STATE.savedPower = 0;
    updateBallInHandBanner();
    trailCtx.clearRect(0,0,logicalWidth,logicalHeight);

    whiteBall = new Ball(logicalWidth * 0.25, logicalHeight / 2, TYPE.CUE, '#fff', 0);
    balls.push(whiteBall);

    const startX = logicalWidth * 0.7;
    const startY = logicalHeight / 2;
    const r = CONFIG.BALL_RADIUS;
    const rackPattern = [1, 1, 0, 0, 2, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0]; 
    let solids = [...PALETTE.SOLIDS], stripes = [...PALETTE.STRIPES];
    let ballIdx = 0;

    for (let col = 0; col < 5; col++) {
        for (let row = 0; row <= col; row++) {
            let x = startX + col * (r * 2 * 0.866 + 1);
            let y = startY - col * (r + 0.5) + row * (r * 2 + 1);
            let typeCode = rackPattern[ballIdx];
            let type, color, id;
            if (typeCode === 2) { type = TYPE.BLACK; color = '#000'; id = 8; }
            else if (typeCode === 0) { type = TYPE.SOLID; color = solids.shift()||'#888'; id=ballIdx+1; }
            else { type = TYPE.STRIPE; color = stripes.shift()||'#888'; id=ballIdx+9; }
            balls.push(new Ball(x, y, type, color, id));
            ballIdx++;
        }
    }
    updateUI();
    updatePowerUI(0);
    showToast("游戏开始");
}

function checkTurn() {
    const isMoving = balls.some(b => b.active && b.vel.mag() > CONFIG.STOP_VELOCITY);
    if (!isMoving && !STATE.canShoot && !STATE.gameOver) {
        resolveTurn();
        STATE.canShoot = true;
    }
}

function resolveTurn() {
    let switchTurn = true;
    let message = "";

    const sunkBlack = STATE.sunkThisTurn.includes(TYPE.BLACK);
    const cueScratch = STATE.foul;

    if (sunkBlack) {
        const isBreakShot = (STATE.shotCount === 1 && !STATE.assigned);
        if (isBreakShot && !cueScratch) {
            message = `玩家 ${STATE.turn} 获胜! (开球进黑八)`;
        } else {
            let myType = (STATE.turn === 1)
                ? STATE.p1Group
                : (STATE.p1Group === TYPE.SOLID ? TYPE.STRIPE : TYPE.SOLID);
            let myRemaining = countRemaining(myType);
            
            if (myRemaining > 0 || !STATE.assigned || cueScratch) {
                message = `玩家 ${STATE.turn} 输了 (违规进黑八)`;
            } else {
                message = `玩家 ${STATE.turn} 获胜!`;
            }
        }
        STATE.gameOver = true;
        STATE.canShoot = false;
        showToast(message);
        showEndScreen(message);
        return;
    }

    if (STATE.foul) {
        message = "犯规! 自由球";
        resetWhiteBall(true);
        switchTurn = true;
    } else if (STATE.sunkThisTurn.length > 0) {
        let firstSunk = STATE.sunkThisTurn[0];
        if (!STATE.assigned) {
            if (firstSunk === TYPE.SOLID || firstSunk === TYPE.STRIPE) {
                if (STATE.turn === 1) {
                    STATE.p1Group = firstSunk;
                } else {
                    STATE.p1Group = (firstSunk === TYPE.SOLID ? TYPE.STRIPE : TYPE.SOLID);
                }
                STATE.assigned = true;
                const p1IsSolids = STATE.p1Group === TYPE.SOLID;
                message = p1IsSolids
                    ? "花色已定: P1 实色 / P2 花色"
                    : "花色已定: P1 花色 / P2 实色";
                switchTurn = false;
            }
        } else {
            let myGroup = (STATE.turn === 1) ? STATE.p1Group : (STATE.p1Group === TYPE.SOLID ? TYPE.STRIPE : TYPE.SOLID);
            if (STATE.sunkThisTurn.includes(myGroup)) { switchTurn = false; message = "好球"; }
            else { switchTurn = true; message = "击错球"; }
        }
    } else { switchTurn = true; }

    const remainingSolids = countRemaining(TYPE.SOLID);
    const remainingStripes = countRemaining(TYPE.STRIPE);
    const remainingBlack = countRemaining(TYPE.BLACK);
    if (!STATE.gameOver && remainingSolids === 0 && remainingStripes === 0 && remainingBlack === 0) {
        const drawMsg = "清台 — 平局";
        STATE.gameOver = true;
        STATE.canShoot = false;
        showToast(drawMsg);
        showEndScreen(drawMsg);
        return;
    }

    if (switchTurn) STATE.turn = STATE.turn === 1 ? 2 : 1;
    if (message) showToast(message);
    updateUI();
    updateBallInHandBanner();
}

function countRemaining(type) { return type ? balls.filter(b => b.active && b.type === type).length : 0; }
function resetWhiteBall(withBallInHand = false) {
    whiteBall.active = true; whiteBall.vel = new Vector(0,0);
    whiteBall.pos = new Vector(logicalWidth * 0.25, logicalHeight / 2);
    STATE.ballInHand = withBallInHand;
    placingBall = false;
    lastPlacementValid = false;
    updateBallInHandBanner();
}

// 物理更新函数：可供主循环和预测器使用
// 将物理逻辑从 resolveCollisions 和 Ball.update 中提取，确保预测与实际运行完全一致
// collisionPredicate: 可选，用于预测模式下筛选碰撞 (return true/false)
function stepPhysics(ballsList, collisionPredicate) {
    let collisions = []; 

    // 1. 球与球碰撞
    for (let i = 0; i < ballsList.length; i++) {
        for (let j = i + 1; j < ballsList.length; j++) {
            let b1 = ballsList[i], b2 = ballsList[j];
            if (!b1.active || !b2.active) continue;
            
            let dist = b1.pos.dist(b2.pos);
            if (dist < CONFIG.BALL_RADIUS * 2) {
                // 如果提供了过滤条件且返回false，则跳过（用于预测模式的“幽灵”逻辑）
                if(collisionPredicate && !collisionPredicate(b1, b2)) continue;

                let normal = b2.pos.sub(b1.pos).normalize();
                let overlap = CONFIG.BALL_RADIUS * 2 - dist;
                b1.pos = b1.pos.sub(normal.mult(overlap * 0.5));
                b2.pos = b2.pos.add(normal.mult(overlap * 0.5));
                
                let relVel = b1.vel.sub(b2.vel);
                let sepVel = Vector.dot(relVel, normal);
                
                // 移除了 sepVel < 0 检查，恢复原始手感
                let newSepVel = -sepVel * CONFIG.BALL_BOUNCE;
                let sepVelVec = normal.mult(newSepVel - sepVel);
                b1.vel = b1.vel.add(sepVelVec.mult(0.5));
                b2.vel = b2.vel.sub(sepVelVec.mult(0.5));
                
                collisions.push({b1, b2});
            }
        }
    }

    // 2. 移动与墙壁反弹
    for(let b of ballsList) {
        if(!b.active) continue;
        
        // 简单欧拉积分
        b.pos = b.pos.add(b.vel);
        b.vel = b.vel.mult(CONFIG.FRICTION);
        
        if(b.vel.mag() < CONFIG.STOP_VELOCITY) b.vel = new Vector(0,0);

        const bound = CONFIG.CUSHION_SIZE + CONFIG.BALL_RADIUS;
        if (b.pos.x < bound) { b.pos.x = bound; b.vel.x *= -CONFIG.WALL_BOUNCE; }
        else if (b.pos.x > logicalWidth - bound) { b.pos.x = logicalWidth - bound; b.vel.x *= -CONFIG.WALL_BOUNCE; }
        if (b.pos.y < bound) { b.pos.y = bound; b.vel.y *= -CONFIG.WALL_BOUNCE; }
        else if (b.pos.y > logicalHeight - bound) { b.pos.y = logicalHeight - bound; b.vel.y *= -CONFIG.WALL_BOUNCE; }
    }
    
    // 3. 进袋检测 (预测模式下通常不移除球，为了简单，若进袋则停止)
    // 注意：这里仅标记停止，不实际移除，以免影响后续渲染逻辑
    for(let b of ballsList) {
        if (!b.active) continue;
        for (let p of pockets) {
            if (b.pos.dist(p) < CONFIG.POCKET_RADIUS) {
                b.vel = new Vector(0,0);
                // 预测模式下可能需要标记为"已进袋"以便特殊处理
            }
        }
    }

    // 返回碰撞对供预测逻辑分析
    return collisions;
}

function resolveCollisions() {
    // 主循环使用与预测相同的逻辑核心
    // 1. 球与球碰撞
    for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
            let b1 = balls[i]; let b2 = balls[j];
            if (!b1.active || !b2.active) continue;
            let dist = b1.pos.dist(b2.pos);
            if (dist < CONFIG.BALL_RADIUS * 2) {
                let normal = b2.pos.sub(b1.pos).normalize();
                let overlap = CONFIG.BALL_RADIUS * 2 - dist;
                b1.pos = b1.pos.sub(normal.mult(overlap * 0.5));
                b2.pos = b2.pos.add(normal.mult(overlap * 0.5));
                let relVel = b1.vel.sub(b2.vel);
                let sepVel = Vector.dot(relVel, normal);
                
                // 恢复无条件反弹，以匹配旧版本手感
                let newSepVel = -sepVel * CONFIG.BALL_BOUNCE;
                let sepVelVec = normal.mult(newSepVel - sepVel);
                b1.vel = b1.vel.add(sepVelVec.mult(0.5));
                b2.vel = b2.vel.sub(sepVelVec.mult(0.5));
            }
        }
    }
    
    // 2. 进袋检测 (主循环特有逻辑：计分、移除)
    for (let b of balls) {
        if (!b.active) continue;
        for (let p of pockets) {
            if (b.pos.dist(p) < CONFIG.POCKET_RADIUS) {
                if (b.type === TYPE.CUE) { STATE.foul = true; b.active = false; }
                else {
                    b.active = false; b.vel = new Vector(0,0);
                    STATE.sunkThisTurn.push(b.type);
                    STATE.scores[STATE.turn] = (STATE.scores[STATE.turn] || 0) + 1;
                    spawnFloatText("+1", p.x, p.y);
                    updateUI();
                }
            }
        }
    }
}

function cloneBallsForSim() {
    const sim = [];
    for (let b of balls) {
        const nb = new Ball(b.pos.x, b.pos.y, b.type, b.color, b.id);
        nb.active = b.active;
        nb.vel = new Vector(b.vel.x, b.vel.y);
        sim.push(nb);
    }
    return sim;
}

function spawnFloatText(text, x, y) {
    const el = document.createElement('div');
    el.className = 'float-text'; el.innerText = text;
    el.style.left = Math.min(x, logicalWidth-50)+'px'; el.style.top = Math.min(y, logicalHeight-50)+'px';
    document.body.appendChild(el); setTimeout(() => el.remove(), 800);
}
function showToast(msg) {
    if (!uiToast) return;
    uiToast.innerText = msg;
    uiToast.style.opacity = "1";
    setTimeout(() => {
        if (uiToast.innerText === msg) {
            uiToast.style.opacity = "0";
        }
    }, 2000);
}
function hideToast() {
    if (uiToast) uiToast.style.opacity = "0";
}
function updateBallInHandBanner() {
    if (!uiBallHandBanner) return;
    if (STATE.ballInHand && !STATE.gameOver) {
        uiBallHandBanner.innerText = `自由球 — 玩家 ${STATE.turn}，拖动白球放置`;
        uiBallHandBanner.classList.add('visible');
    } else {
        uiBallHandBanner.classList.remove('visible');
    }
}
function showEndScreen(msg) {
    if (uiEndMessage) uiEndMessage.innerText = msg;
    if (uiEndScreen) uiEndScreen.classList.add('visible');
    updateBallInHandBanner();
}
function hideEndScreen() {
    if (uiEndScreen) uiEndScreen.classList.remove('visible');
}
function updateUI() {
    // 计分板已移至 Canvas 绘制，旧 DOM 逻辑移除
}

function buildTargetsForPlayer(isP1) {
    if (!STATE.assigned) return [];
    const myGroup = isP1 ? STATE.p1Group : (STATE.p1Group === TYPE.SOLID ? TYPE.STRIPE : TYPE.SOLID);
    if (myGroup !== TYPE.SOLID && myGroup !== TYPE.STRIPE) return [];

    const groupBalls = balls
        .filter(b => b.type === myGroup && typeof b.id === 'number' && b.id !== 8)
        .sort((a, b) => (a.id || 0) - (b.id || 0));

    const remainingCount = groupBalls.filter(b => b.active).length;

    const blackRemaining = countRemaining(TYPE.BLACK) > 0;
    if (remainingCount === 0 && blackRemaining) {
        return [{ id: 8, isRemaining: true, isBlack: true, color: '#000' }];
    }

    return groupBalls.map(b => ({
        id: b.id,
        isRemaining: b.active,
        isBlack: false,
        color: b.color
    }));
}

function drawScoreboard(ctx) {
    const c = CONFIG.CUSHION_SIZE;
    const y = c + 24;
    const cardWidth = 150;
    const cardHeight = 44;
    const gap = 18;
    const centerX = logicalWidth / 2;
    const p1x = centerX - cardWidth - gap/2;
    const p2x = centerX + gap/2;

    const drawCard = (x, label, targets, isActive, isP1) => {
        ctx.save();
        const cardRadius = 12;

        ctx.beginPath();
        ctx.moveTo(x + cardRadius, y);
        ctx.lineTo(x + cardWidth - cardRadius, y);
        ctx.quadraticCurveTo(x + cardWidth, y, x + cardWidth, y + cardRadius);
        ctx.lineTo(x + cardWidth, y + cardHeight - cardRadius);
        ctx.quadraticCurveTo(x + cardWidth, y + cardHeight, x + cardWidth - cardRadius, y + cardHeight);
        ctx.lineTo(x + cardRadius, y + cardHeight);
        ctx.quadraticCurveTo(x, y + cardHeight, x, y + cardHeight - cardRadius);
        ctx.lineTo(x, y + cardRadius);
        ctx.quadraticCurveTo(x, y, x + cardRadius, y);

        const base = "rgba(15,15,25,0.86)";
        ctx.fillStyle = base;
        ctx.fill();
        ctx.strokeStyle = isActive ? "rgba(255,255,255,0.35)" : "rgba(255,255,255,0.15)";
        ctx.lineWidth = isActive ? 2 : 1;
        ctx.stroke();

        ctx.font = "11px 'Noto Sans SC', sans-serif";
        ctx.textBaseline = "top";
        ctx.textAlign = "left";
        ctx.fillStyle = isP1 ? PALETTE.P1_COLOR : PALETTE.P2_COLOR;
        ctx.fillText(label, x + 10, y + 6);

        const rowY = y + 20;
        const maxPerRow = 8;
        const dotRadius = 7;
        const spacing = 4 + dotRadius*2;
        const startX = x + 12;

        if (targets && targets.length) {
            ctx.font = "9px Inter";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            let idx = 0;
            for (let t of targets) {
                if (idx >= maxPerRow) break;
                const cx = startX + idx * spacing;
                const cy = rowY;
                const isRem = t.isRemaining;

                ctx.beginPath();
                if (t.isBlack || t.id === 8) {
                    ctx.fillStyle = isRem ? "#000" : "rgba(50,50,50,0.9)";
                } else if (isRem) {
                    ctx.fillStyle = t.color || (isP1 ? PALETTE.P1_COLOR : PALETTE.P2_COLOR);
                } else {
                    ctx.fillStyle = "rgba(80,80,90,0.9)";
                }
                ctx.arc(cx, cy, dotRadius, 0, Math.PI*2);
                ctx.fill();

                ctx.strokeStyle = "rgba(0,0,0,0.4)";
                ctx.lineWidth = 0.8;
                ctx.stroke();

                const textColor = isRem ? "#ffffff" : "rgba(180,180,190,0.9)";
                ctx.fillStyle = textColor;
                ctx.fillText(String(t.id), cx, cy+0.5);

                idx++;
            }
        }

        ctx.restore();
    };

    let p1Label = "ANY";
    let p2Label = "ANY";
    let p1Targets = [];
    let p2Targets = [];
    if (STATE.assigned) {
        const p1Solids = STATE.p1Group === TYPE.SOLID;
        p1Label = p1Solids ? "实色球 ●" : "花色球 ◎";
        p2Label = p1Solids ? "花色球 ◎" : "实色球 ●";
        p1Targets = buildTargetsForPlayer(true);
        p2Targets = buildTargetsForPlayer(false);
    }

    drawCard(p1x, p1Label, p1Targets, STATE.turn === 1, true);
    drawCard(p2x, p2Label, p2Targets, STATE.turn === 2, false);
}
function adjustBrightness(col, amt) {
    let usePound = false; if (col[0] == "#") { col = col.slice(1); usePound = true; }
    let num = parseInt(col,16); let r = (num >> 16) + amt; let b = ((num >> 8) & 0x00FF) + amt; let g = (num & 0x0000FF) + amt;
    r = r > 255 ? 255 : (r < 0 ? 0 : r); b = b > 255 ? 255 : (b < 0 ? 0 : b); g = g > 255 ? 255 : (g < 0 ? 0 : g);
    return (usePound?"#":"") + (g | (b << 8) | (r << 16)).toString(16).padStart(6,0);
}

function loop() {
    ctx.clearRect(0, 0, logicalWidth, logicalHeight);
    
    // 键盘蓄力逻辑
    if (STATE.spaceCharging) {
        const chargeSpeed = STATE.aimMode === 'offline' ? 0.008 : 0.02;
        STATE.power += chargeSpeed * STATE.spaceChargeDir;
        if (STATE.power >= 1) { STATE.power = 1; STATE.spaceChargeDir = -1; }
        if (STATE.power <= 0) { STATE.power = 0; STATE.spaceChargeDir = 1; }
        updatePowerUI(STATE.power);
    }

    trailCtx.globalCompositeOperation = 'destination-out';
    trailCtx.fillStyle = `rgba(0, 0, 0, ${CONFIG.TRAIL_FADE})`;
    trailCtx.fillRect(0, 0, logicalWidth, logicalHeight);
    trailCtx.globalCompositeOperation = 'source-over';

    let felt = ctx.createRadialGradient(logicalWidth/2, logicalHeight/2, logicalWidth*0.2, logicalWidth/2, logicalHeight/2, logicalWidth);
    felt.addColorStop(0, PALETTE.FELT[0]); felt.addColorStop(1, PALETTE.FELT[1]);
    ctx.fillStyle = felt; ctx.fillRect(0, 0, logicalWidth, logicalHeight);
    ctx.drawImage(trailCanvas, 0, 0, logicalWidth, logicalHeight);
    
    const c = CONFIG.CUSHION_SIZE;
    ctx.fillStyle = "#0a0a10";
    ctx.fillRect(0,0,logicalWidth,c); ctx.fillRect(0,logicalHeight-c,logicalWidth,c);
    ctx.fillRect(0,0,c,logicalHeight); ctx.fillRect(logicalWidth-c,0,c,logicalHeight);
    ctx.strokeStyle = "rgba(255,255,255,0.1)"; ctx.lineWidth=1;
    ctx.strokeRect(c,c,logicalWidth-c*2,logicalHeight-c*2);
    
    ctx.fillStyle = "#000";
    for(let p of pockets) { ctx.beginPath(); ctx.arc(p.x, p.y, CONFIG.POCKET_RADIUS, 0, Math.PI*2); ctx.fill(); }

    // 右侧库边垂直力度条
    const barC = CONFIG.CUSHION_SIZE;
    const barWidth = 8;
    const barTop = barC + 16;
    const barBottom = logicalHeight - barC - 16;
    const barHeight = Math.max(0, barBottom - barTop);
    const barX = logicalWidth - barC + (barC - barWidth) * 0.5;

    ctx.save();
    const baseGrad = ctx.createLinearGradient(barX, barTop, barX, barBottom);
    baseGrad.addColorStop(0, "rgba(255,255,255,0.65)");
    baseGrad.addColorStop(1, "rgba(230,230,230,0.65)");
    ctx.fillStyle = baseGrad;
    ctx.fillRect(barX, barTop, barWidth, barHeight);
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 1;
    ctx.strokeRect(barX+0.5, barTop+0.5, barWidth-1, barHeight-1);

    const pct = Math.max(0, Math.min(1, STATE.power || 0));
    if (pct > 0) {
        const color = STATE.turn === 1 ? PALETTE.P1_COLOR : PALETTE.P2_COLOR;
        const filled = barHeight * pct;
        const fillGrad = ctx.createLinearGradient(barX, barBottom, barX, barTop);
        fillGrad.addColorStop(0, adjustBrightness(color, -10));
        fillGrad.addColorStop(1, adjustBrightness(color, 40));
        ctx.fillStyle = fillGrad;
        ctx.fillRect(barX, barBottom - filled, barWidth, filled);
    }
    ctx.restore();

    drawScoreboard(ctx);

    resolveCollisions();
    checkTurn();

    for(let b of balls) { b.update(); b.draw(ctx); }
    
    if (STATE.canShoot && !STATE.gameOver && !STATE.ballInHand) {
        const start = whiteBall.pos;
        const dir = new Vector(Math.cos(STATE.aimAngle), Math.sin(STATE.aimAngle)).normalize();
        const color = STATE.turn === 1 ? PALETTE.P1_COLOR : PALETTE.P2_COLOR;
        const maxDist = Math.max(logicalWidth, logicalHeight);

        let hitBall = null;
        let baseEnd = start.add(dir.mult(maxDist * 0.9));

        const mode = STATE.aimMode || 'basic';

        if (mode === 'basic' || mode === 'advanced') {
            let hitDist = maxDist;
            const R = CONFIG.BALL_RADIUS * 2;
            for (let b of balls) {
                if (!b.active || b === whiteBall) continue;

                const f = start.sub(b.pos);
                const a = 1;
                const bCoef = 2 * Vector.dot(dir, f);
                const cTerm = f.mag() * f.mag() - R*R;
                const disc = bCoef*bCoef - 4*a*cTerm;
                if (disc < 0) continue;

                const sqrtD = Math.sqrt(disc);
                let t1 = (-bCoef - sqrtD) / (2*a);
                let t2 = (-bCoef + sqrtD) / (2*a);

                let tHit = Number.POSITIVE_INFINITY;
                if (t1 > 0 && t1 < tHit) tHit = t1;
                if (t2 > 0 && t2 < tHit) tHit = t2;
                if (!isFinite(tHit) || tHit <= 0 || tHit > maxDist) continue;

                if (tHit < hitDist) {
                    hitDist = tHit;
                    hitBall = b;
                }
            }

            if (hitBall) {
                baseEnd = start.add(dir.mult(hitDist));
            }
        } else if (mode === 'offline') {
            // 离线预测模式逻辑
            const simBalls = cloneBallsForSim();
            const simWhite = simBalls.find(b => b.type === TYPE.CUE);
            const cueId = simWhite ? simWhite.id : -1;
            
            if (simWhite) {
                const rawP = (STATE.power == null ? 0 : STATE.power);
                const previewPower = rawP > 0 ? rawP : 0.6;
                simWhite.vel = computeShotVelocity(dir, previewPower);
            }

            const cuePathBefore = []; // 碰撞前白球轨迹
            const cuePathAfter = [];  // 碰撞后白球轨迹
            const targetPath = [];    // 目标球轨迹
            let firstHitFound = false;
            let targetId = -1;

            const maxSteps = 1200; 
            let allStopped = false;

            // 如果一开始就记录当前位置
            if(simWhite) cuePathBefore.push({x:simWhite.pos.x, y:simWhite.pos.y});

            for (let step = 0; step < maxSteps; step++) {
                // 碰撞过滤器逻辑
                const collisionPredicate = (b1, b2) => {
                    const isCue = (b1.id === cueId || b2.id === cueId);
                    
                    if (!firstHitFound) {
                        // 阶段一：寻找第一次碰撞，只关心涉及白球的碰撞
                        return isCue;
                    } else {
                        // 阶段二：碰撞后，禁止所有球与球的碰撞
                        return false; 
                    }
                };

                // 使用与主循环完全一致的 stepPhysics 进行模拟，不再使用子步
                const collisions = stepPhysics(simBalls, collisionPredicate);

                // 检查是否发生第一次碰撞
                if (!firstHitFound && simWhite) {
                    for(let c of collisions) {
                        let other = null;
                        if(c.b1.id === cueId) other = c.b2;
                        else if(c.b2.id === cueId) other = c.b1;

                        if(other && other.type !== TYPE.CUE) {
                            firstHitFound = true;
                            targetId = other.id;
                            // 记录碰撞点，作为轨迹的分界
                            cuePathBefore.push({x:simWhite.pos.x, y:simWhite.pos.y});
                            cuePathAfter.push({x:simWhite.pos.x, y:simWhite.pos.y});
                            targetPath.push({x:other.pos.x, y:other.pos.y});
                            break;
                        }
                    }
                }

                // 记录轨迹点
                if (simWhite) {
                    if (!firstHitFound) {
                        cuePathBefore.push({x: simWhite.pos.x, y: simWhite.pos.y});
                    } else {
                        cuePathAfter.push({x: simWhite.pos.x, y: simWhite.pos.y});
                    }
                }

                if (firstHitFound && targetId !== -1) {
                    const target = simBalls.find(b => b.id === targetId);
                    if (target) {
                        targetPath.push({x: target.pos.x, y: target.pos.y});
                    }
                }
                
                // 提前结束检查
                if (step > 10) {
                    let moving = false;
                    if(simWhite && simWhite.vel.mag() > CONFIG.STOP_VELOCITY) moving = true;
                    if(targetId !== -1) {
                        const t = simBalls.find(b => b.id === targetId);
                        if(t && t.vel.mag() > CONFIG.STOP_VELOCITY) moving = true;
                    }
                    if(!moving) break;
                }
            }

            // 绘制：碰撞前白球 (含通道宽度)
            if (cuePathBefore.length > 1) {
                // 1. 宽半透明色带（表示球体直径）
                ctx.beginPath();
                ctx.moveTo(cuePathBefore[0].x, cuePathBefore[0].y);
                for (let i = 1; i < cuePathBefore.length; i++) {
                    ctx.lineTo(cuePathBefore[i].x, cuePathBefore[i].y);
                }
                ctx.strokeStyle = "rgba(255,255,255,0.12)"; // 非常淡的背景带
                ctx.lineWidth = CONFIG.BALL_RADIUS * 2; // 球体直径
                ctx.lineCap = 'round';
                ctx.stroke();

                // 2. 细中心线
                ctx.beginPath();
                ctx.moveTo(cuePathBefore[0].x, cuePathBefore[0].y);
                for (let i = 1; i < cuePathBefore.length; i++) {
                    ctx.lineTo(cuePathBefore[i].x, cuePathBefore[i].y);
                }
                ctx.strokeStyle = "rgba(255,255,255,0.5)";
                ctx.lineWidth = 1.5;
                ctx.setLineDash([6, 6]); 
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // 绘制：碰撞后白球 (含通道宽度)
            if (cuePathAfter.length > 1) {
                // 1. 宽半透明色带
                ctx.beginPath();
                ctx.moveTo(cuePathAfter[0].x, cuePathAfter[0].y);
                for (let i = 1; i < cuePathAfter.length; i++) {
                    ctx.lineTo(cuePathAfter[i].x, cuePathAfter[i].y);
                }
                ctx.strokeStyle = "rgba(255,255,255,0.08)";
                ctx.lineWidth = CONFIG.BALL_RADIUS * 2;
                ctx.lineCap = 'round';
                ctx.stroke();

                // 2. 细实线
                ctx.beginPath();
                ctx.moveTo(cuePathAfter[0].x, cuePathAfter[0].y);
                for (let i = 1; i < cuePathAfter.length; i++) {
                    ctx.lineTo(cuePathAfter[i].x, cuePathAfter[i].y);
                }
                ctx.strokeStyle = "rgba(255,255,255,0.9)"; 
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }

            // 绘制：目标球轨迹 (含通道宽度)
            if (targetPath.length > 1) {
                const pColor = STATE.turn === 1 ? PALETTE.P1_COLOR : PALETTE.P2_COLOR;
                
                // 1. 宽半透明色带
                ctx.beginPath();
                ctx.moveTo(targetPath[0].x, targetPath[0].y);
                for (let i = 1; i < targetPath.length; i++) {
                    ctx.lineTo(targetPath[i].x, targetPath[i].y);
                }
                // 将颜色转为 rgba 以设置透明度
                // 简单 hack: 假设 pColor 是 hex，我们用一个通用的半透明色或者尝试解析
                // 这里直接用白色半透明叠加，或者手动写死一点颜色
                ctx.strokeStyle = "rgba(255,255,255,0.1)"; 
                ctx.lineWidth = CONFIG.BALL_RADIUS * 2;
                ctx.lineCap = 'round';
                ctx.stroke();

                // 2. 细实线
                ctx.beginPath();
                ctx.moveTo(targetPath[0].x, targetPath[0].y);
                for (let i = 1; i < targetPath.length; i++) {
                    ctx.lineTo(targetPath[i].x, targetPath[i].y);
                }
                ctx.strokeStyle = pColor;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 终点圆点
                const last = targetPath[targetPath.length-1];
                ctx.beginPath();
                ctx.arc(last.x, last.y, 4, 0, Math.PI*2);
                ctx.fillStyle = pColor;
                ctx.fill();
            }
        }

        // 母球光晕
        ctx.beginPath();
        ctx.arc(start.x, start.y, CONFIG.BALL_RADIUS + 16, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        ctx.lineWidth = 1;
        ctx.stroke();

        // 基础瞄准虚线 (总是显示，作为参考)
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(start.x + dir.x * maxDist, start.y + dir.y * maxDist);
        ctx.strokeStyle = "rgba(255,255,255,0.1)";
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 8]); // 很淡的虚线
        ctx.stroke();
        ctx.restore();

        if (hitBall && STATE.aimMode !== 'cue') {
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(baseEnd.x, baseEnd.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2.4;
            ctx.setLineDash([10, 4]);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.beginPath();
            ctx.arc(baseEnd.x, baseEnd.y, 4, 0, Math.PI*2);
            ctx.fillStyle = color;
            ctx.fill();

            if (STATE.aimMode === 'advanced') {
                const impactPoint = baseEnd;
                const n = hitBall.pos.sub(impactPoint).normalize();
                const v = dir;
                const vDotN = Vector.dot(v, n);

                const approach = Math.abs(vDotN);

                const objDir = n;
                const objStart = hitBall.pos;
                const travelLen = CONFIG.BALL_RADIUS * 8;
                const objEnd = objStart.add(objDir.mult(travelLen));

                ctx.beginPath();
                ctx.moveTo(objStart.x, objStart.y);
                ctx.lineTo(objEnd.x, objEnd.y);
                ctx.strokeStyle = "rgba(255,255,255,0.45)";
                ctx.lineWidth = 1.6;
                ctx.setLineDash([3, 6]);
                ctx.stroke();
                ctx.setLineDash([]);

                if (approach >= 0.18) {
                    let cueDir = v.sub(n.mult(vDotN));
                    if (cueDir.mag() > 0.0001) {
                        cueDir = cueDir.normalize();
                    } else {
                        cueDir = v.sub(n.mult(2 * vDotN)).normalize();
                    }

                    const cueStart = impactPoint.add(cueDir.mult(CONFIG.BALL_RADIUS * 1.2));
                    const cueEnd = cueStart.add(cueDir.mult(travelLen));

                    ctx.beginPath();
                    ctx.moveTo(cueStart.x, cueStart.y);
                    ctx.lineTo(cueEnd.x, cueEnd.y);
                    ctx.strokeStyle = "rgba(255,255,255,0.35)";
                    ctx.lineWidth = 1.4;
                    ctx.setLineDash([2, 6]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
    }
    requestAnimationFrame(loop);
}

init();
</script>
</body>
</html>