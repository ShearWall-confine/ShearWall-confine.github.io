<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini Pool: Cross-Platform Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            touch-action: none;
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        /* --- Top control stack (embedded into top cushion) --- */
        #ui-shell {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 6px 24px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 12px;
            z-index: 20;
            pointer-events: none;
        }

        #action-stack {
            display: flex;
            gap: 12px;
            pointer-events: auto;
        }

        #back-home-btn,
        #settings-toggle {
            padding: 6px 14px;
            border-radius: 999px;
            border: none;
            background: transparent;
            color: rgba(240,240,255,0.9);
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
            text-decoration: none;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease;
        }

        #settings-toggle {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        #back-home-btn:hover,
        #settings-toggle:hover {
            background: none;
            transform: translateY(-1px);
            text-shadow: 0 0 6px rgba(255,255,255,0.5);
        }

        /* --- Settings overlay & dialog --- */
        #settings-panel {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 40;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #settings-panel.visible {
            display: flex;
        }

        .settings-content {
            width: 60vw;
            max-width: 420px;
            max-height: 60vh;
            padding: 18px 20px;
            border-radius: 16px;
            background: rgba(15, 15, 25, 0.96);
            border: 1px solid rgba(255,255,255,0.12);
            box-sizing: border-box;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            color: #fff;
        }

        #settings-panel h3 {
            margin: 0 0 10px;
            font-size: 16px;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #settings-panel label {
            font-size: 12px;
            letter-spacing: 0.5px;
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
        }

        #settings-panel input,
        #settings-panel select {
            width: 100%;
            margin-top: 6px;
        }

        #settings-panel input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.25);
            outline: none;
        }

        #settings-panel input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }

        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 12px;
        }

        .toggle-row input[type="checkbox"] {
            width: 34px;
            height: 18px;
        }

        .spin-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .spin-row input[type="range"] {
            flex: 1;
        }

        .spin-btn {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.4);
            background: rgba(15,15,25,0.9);
            color: #fff;
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
            padding: 0;
        }

        .spin-btn:active {
            background: rgba(60,60,80,0.9);
            transform: scale(0.96);
        }

        #apply-settings {
            margin: 8px 0 12px 0;
            width: 100%;
            padding: 8px 0;
            border-radius: 10px;
            border: none;
            font-weight: 600;
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            cursor: pointer;
        }

        #close-settings {
            background: none;
            border: none;
            color: rgba(255,255,255,0.6);
            font-size: 18px;
            cursor: pointer;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair; /* desktop crosshair cursor */
            z-index: 1; /* table & balls under UI overlays */
        }

        /* --- Scoreboard strip (embedded on felt) --- */
        #ui-layer {
            display: none; /* visual scoreboard now drawn directly on canvas */
        }

        .player-card {
            background: rgba(20, 20, 30, 0.55);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 4px 12px;
            display: flex;
            flex-direction: column;
            min-width: 80px;
            transition: all 0.3s ease;
            opacity: 0.5;
            transform: scale(0.95);
        }

        .player-card.active {
            opacity: 1;
            transform: scale(1);
            background: rgba(40, 40, 50, 0.6);
            border-color: rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }

        .target-type {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
            color: #aaa;
        }
        
        .p1-active .target-type { color: #4facfe; }
        .p2-active .target-type { color: #f093fb; }

        .score-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            color: white;
            font-weight: 700;
            font-size: 12px;
            min-width: 90px;
        }

        .score-value {
            font-size: 16px;
            font-weight: 800;
            color: #fff;
        }

        /* --- (Legacy) DOM power column: hidden, logic moved into bottom cushion --- */
        #power-control {
            display: none;
        }

        /* --- Mobile fine-tune controls --- */
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            left: 30px;
            display: none; /* hidden until touch detected */
            gap: 20px;
            z-index: 20;
            pointer-events: auto;
        }

        .fine-tune-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            touch-action: manipulation;
            transition: all 0.1s;
        }

        .fine-tune-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        /* --- Desktop keyboard hint --- */
        #desktop-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 20px;
            pointer-events: none;
            display: none; /* revealed when mouse input detected */
            white-space: nowrap;
        }
        
        .key-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
            font-weight: 600;
            margin: 0 4px;
            font-size: 10px;
        }

        /* --- Toasts & overlays --- */
        #game-toast {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(8px);
            padding: 10px 20px;
            border-radius: 12px;
            color: white;
            font-size: 14px;
            font-weight: 700;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 30;
        }

        .float-text {
            position: absolute;
            color: white;
            font-weight: 800;
            font-size: 20px;
            pointer-events: none;
            animation: popUp 0.8s ease-out forwards;
            text-shadow: 0 2px 8px rgba(0,0,0,0.6);
            z-index: 5;
        }

        #ball-hand-banner {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 22px;
            border-radius: 999px;
            background: rgba(10, 10, 20, 0.8);
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.5px;
            border: 1px solid rgba(255,255,255,0.2);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
            z-index: 35;
        }

        #ball-hand-banner.visible {
            opacity: 1;
        }

        #end-screen {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 50;
        }

        #end-screen.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .end-content {
            background: rgba(20,20,30,0.9);
            border-radius: 20px;
            padding: 30px 40px;
            text-align: center;
            color: #fff;
            border: 1px solid rgba(255,255,255,0.1);
            min-width: 260px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }

        .end-content h2 {
            margin: 0 0 20px;
            font-size: 24px;
            letter-spacing: 1px;
        }

        #restart-btn {
            padding: 10px 26px;
            border-radius: 999px;
            border: none;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 0.8px;
            cursor: pointer;
            color: #fff;
            background: linear-gradient(135deg, #00d2ff, #3a7bd5);
            box-shadow: 0 6px 20px rgba(0, 210, 255, 0.3);
        }

        #restart-btn:hover {
            transform: translateY(-1px);
        }

        /* --- Landscape mobile: compact settings panel --- */
        @media (max-height: 520px) and (max-width: 1024px) {
            .settings-content {
                width: 70vw;
                max-width: 480px;
                max-height: 70vh;
                padding: 12px 16px;
            }

            #settings-panel h3 {
                font-size: 14px;
                margin-bottom: 6px;
            }

            #settings-panel label {
                font-size: 11px;
                margin-top: 8px;
            }

            #apply-settings {
                margin: 8px 0 10px 0;
                padding: 8px 0;
            }
        }

        @keyframes popUp {
            0% { opacity: 0; transform: translateY(0) scale(0.5); }
            50% { opacity: 1; transform: translateY(-30px) scale(1.2); }
            100% { opacity: 0; transform: translateY(-50px) scale(1); }
        }
    </style>
</head>
<body>

<div id="ui-shell">
    <div id="action-stack">
        <a id="back-home-btn" href="../index.html">← Back to Hub</a>
        <button id="settings-toggle">⚙ Settings</button>
    </div>
</div>

<div id="ui-layer">
    <div id="p1-card" class="player-card active p1-active">
        <div class="target-type" id="p1-type">ANY</div>
        <div class="score-info">
            <span>PLAYER 1</span>
            <span class="score-value" id="p1-score">0</span>
        </div>
    </div>
    <div id="p2-card" class="player-card">
        <div class="target-type" id="p2-type">ANY</div>
        <div class="score-info">
            <span>PLAYER 2</span>
            <span class="score-value" id="p2-score">0</span>
        </div>
    </div>
</div>

<div id="settings-panel">
    <div class="settings-content">
        <h3>Table Settings <button id="close-settings">×</button></h3>

        <button id="apply-settings">Apply &amp; Re-rack</button>

        <label>Ball radius <span id="ball-size-display">10px</span></label>
        <div class="spin-row">
            <button class="spin-btn" data-target="ball-size-input" data-step="1" data-min="6" data-max="100">−</button>
            <input type="range" min="6" max="100" step="1" id="ball-size-input" value="10">
            <button class="spin-btn" data-target="ball-size-input" data-step="1" data-min="6" data-max="100">+</button>
        </div>
        
        <label>Pocket size <span id="pocket-size-display">22px</span></label>
        <div class="spin-row">
            <button class="spin-btn" data-target="pocket-size-input" data-step="2" data-min="10" data-max="200">−</button>
            <input type="range" min="10" max="200" step="1" id="pocket-size-input" value="22">
            <button class="spin-btn" data-target="pocket-size-input" data-step="2" data-min="10" data-max="200">+</button>
        </div>

        <label>Max shot power <span id="power-max-display">200</span></label>
        <div class="spin-row">
            <button class="spin-btn" data-target="power-max-input" data-step="20" data-min="80" data-max="10000">−</button>
            <input type="range" min="80" max="10000" step="10" id="power-max-input" value="200">
            <button class="spin-btn" data-target="power-max-input" data-step="20" data-min="80" data-max="10000">+</button>
        </div>

        <label>Table friction <span id="friction-display">0.988</span></label>
        <div class="spin-row">
            <button class="spin-btn" data-target="friction-input" data-step="0.01" data-min="0" data-max="1">−</button>
            <input type="range" min="0" max="1" step="0.001" id="friction-input" value="0.988">
            <button class="spin-btn" data-target="friction-input" data-step="0.01" data-min="0" data-max="1">+</button>
        </div>

        <div class="toggle-row">
            <span>Advanced aiming (experimental)</span>
            <input type="checkbox" id="advanced-aim-toggle">
        </div>
        
        <label>Felt palette</label>
        <select id="felt-select">
            <option value="midnight">Midnight Blue</option>
            <option value="classic">Classic Green</option>
            <option value="ember">Ember Night</option>
            <option value="aurora">Aurora Neon</option>
            <option value="metal_steel">Steel Metal</option>
            <option value="metal_gold">Gold Metal</option>
            <option value="metal_copper">Copper Metal</option>
            <option value="diamond_cyan">Cyan Diamond</option>
            <option value="diamond_violet">Violet Diamond</option>
            <option value="plastic_blue">Blue Plastic</option>
            <option value="plastic_red">Red Plastic</option>
            <option value="stone_marble">Marble Stone</option>
            <option value="stone_slate">Slate Stone</option>
        </select>

        <label>Ball material</label>
        <select id="ball-material-select">
            <option value="classic">Classic</option>
            <option value="metal_steel">Steel Metal</option>
            <option value="metal_gold">Gold Metal</option>
            <option value="metal_copper">Copper Metal</option>
            <option value="diamond_cyan">Cyan Diamond</option>
            <option value="diamond_violet">Violet Diamond</option>
            <option value="plastic_blue">Blue Plastic</option>
            <option value="plastic_red">Red Plastic</option>
            <option value="stone_marble">Marble Stone</option>
            <option value="stone_slate">Slate Stone</option>
        </select>
    </div>
</div>

<div id="ball-hand-banner">Ball in hand — drag the cue ball to place it.</div>

<div id="end-screen">
    <div class="end-content">
        <h2 id="end-message">Rack complete</h2>
        <button id="restart-btn">Start New Rack</button>
    </div>
</div>

<!-- Power column -->
<div id="power-control">
    <div id="power-track">
        <div id="power-fill"></div>
        <div id="power-handle"></div>
    </div>
</div>

<!-- Mobile fine tune controls -->
<div id="mobile-controls">
    <div class="fine-tune-btn" id="btn-left">↺</div>
    <div class="fine-tune-btn" id="btn-right">↻</div>
</div>

<!-- Desktop hint -->
<div id="desktop-hint">
    Use <span class="key-badge">←</span> <span class="key-badge">→</span> to Aim &nbsp;|&nbsp; Hold <span class="key-badge">SPACE</span> to Shoot
</div>

<div id="game-toast"></div>
<canvas id="gameCanvas"></canvas>

<script>
// --- Config ---
const CONFIG = {
    BALL_RADIUS: 10,
    POCKET_RADIUS: 22,
    CUSHION_SIZE: 20,
    FRICTION: 0.988,
    WALL_BOUNCE: 0.75,
    BALL_BOUNCE: 0.94,
    MAX_POWER: 200,
    POWER_SCALE: 0.14,
    STOP_VELOCITY: 0.05,
    TRAIL_FADE: 0.07,
    AIM_SENSITIVITY_TOUCH: 0.005,
    AIM_SENSITIVITY_KEY: 0.01
};

const TYPE = { CUE: 0, SOLID: 1, STRIPE: 2, BLACK: 3 };
const PALETTE = {
    BG: '#050505',
    FELT: ['#0b4d0b', '#062b06'], // default: classic green
    P1_COLOR: '#4facfe',
    P2_COLOR: '#f093fb',
    SOLIDS: ['#FFD700', '#FF6B6B', '#4ECDC4', '#1A535C', '#FF9F1C', '#2E86AB', '#8D99AE'],
    STRIPES: ['#FFE66D', '#FF8C94', '#96CEB4', '#45B8AC', '#FFAD60', '#5DADE2', '#A3E4D7']
};

const BASE_CONFIG = {
    BALL_RADIUS: CONFIG.BALL_RADIUS,
    POCKET_RADIUS: CONFIG.POCKET_RADIUS,
    POWER_SCALE: CONFIG.POWER_SCALE,
    MAX_POWER: CONFIG.MAX_POWER,
    FRICTION: CONFIG.FRICTION
};

const SETTINGS = {
    ballRadius: CONFIG.BALL_RADIUS,
    pocketRadius: CONFIG.POCKET_RADIUS,
    feltScheme: 'classic',
    maxPower: CONFIG.MAX_POWER,
    friction: CONFIG.FRICTION,
    ballMaterial: 'classic',
    advancedAim: false
};

const FELT_SCHEMES = {
    midnight: ['#001a33', '#000814'],
    classic: ['#0b4d0b', '#062b06'],
    ember: ['#331111', '#120505'],
    aurora: ['#002b36', '#00111b'],
    metal_steel: ['#3a3f4a', '#16181e'],
    metal_gold: ['#b88a1a', '#3c2604'],
    metal_copper: ['#b45b33', '#34150d'],
    diamond_cyan: ['#0c3b52', '#010b16'],
    diamond_violet: ['#34154f', '#05020d'],
    plastic_blue: ['#004b8d', '#02111f'],
    plastic_red: ['#7b1616', '#250202'],
    stone_marble: ['#e5e5e5', '#9e9e9e'],
    stone_slate: ['#3b3e46', '#14161a']
};

const STATE = {
    turn: 1,
    assigned: false,
    p1Group: null,
    aimAngle: Math.PI/2,
    power: 0,
    isCharging: false,
    spaceCharging: false, // keyboard charging flag
    spaceChargeDir: 1,    // toggles charge direction
    sunkThisTurn: [],
    foul: false,
    gameOver: false,
    canShoot: true,
    inputType: 'unknown', // 'mouse' or 'touch'
    shotCount: 0,         // total shots taken this rack
    scores: {1: 0, 2: 0},
    ballInHand: false,
    ballMaterial: 'classic',
    advancedAim: false
};

class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vector(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() { let m = this.mag(); return m === 0 ? new Vector(0,0) : new Vector(this.x / m, this.y / m); }
    dist(v) { return Math.sqrt((this.x - v.x) ** 2 + (this.y - v.y) ** 2); }
    
    // Added missing dot-product helper
    static dot(v1, v2) { return v1.x * v2.x + v1.y * v2.y; }
}

class Ball {
    constructor(x, y, type, color, id) {
        this.pos = new Vector(x, y);
        this.vel = new Vector(0, 0);
        this.type = type;
        this.color = color;
        this.id = id;
        this.active = true;
    }

    update() {
        if (!this.active) return;
        if (this.vel.mag() > 1) {
            trailCtx.beginPath();
            if (this.type === TYPE.SOLID || this.type === TYPE.BLACK || this.type === TYPE.CUE) {
                trailCtx.arc(this.pos.x, this.pos.y, CONFIG.BALL_RADIUS * 0.8, 0, Math.PI * 2);
                trailCtx.fillStyle = this.type === TYPE.CUE ? 'rgba(255,255,255,0.2)' : this.color;
                trailCtx.fill();
            } else {
                trailCtx.arc(this.pos.x, this.pos.y, CONFIG.BALL_RADIUS * 0.6, 0, Math.PI * 2);
                trailCtx.fillStyle = this.color;
                trailCtx.globalAlpha = 0.4;
                trailCtx.fill();
                trailCtx.globalAlpha = 1.0;
            }
        }
        this.pos = this.pos.add(this.vel);
        this.vel = this.vel.mult(CONFIG.FRICTION);
        if (this.vel.mag() < CONFIG.STOP_VELOCITY) this.vel = new Vector(0, 0);

        const bound = CONFIG.CUSHION_SIZE + CONFIG.BALL_RADIUS;
        if (this.pos.x < bound) { this.pos.x = bound; this.vel.x *= -CONFIG.WALL_BOUNCE; }
        if (this.pos.x > logicalWidth - bound) { this.pos.x = logicalWidth - bound; this.vel.x *= -CONFIG.WALL_BOUNCE; }
        if (this.pos.y < bound) { this.pos.y = bound; this.vel.y *= -CONFIG.WALL_BOUNCE; }
        if (this.pos.y > logicalHeight - bound) { this.pos.y = logicalHeight - bound; this.vel.y *= -CONFIG.WALL_BOUNCE; }
    }

    draw(ctx) {
        if (!this.active) return;
        const x = this.pos.x;
        const y = this.pos.y;
        const r = CONFIG.BALL_RADIUS;
        const material = STATE.ballMaterial || 'classic';

        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.beginPath(); ctx.arc(x + r*0.3, y + r*0.3, r, 0, Math.PI * 2); ctx.fill();

        // Cue ball rendering
        if (this.type === TYPE.CUE) {
            if (material.startsWith('metal_')) {
                // metallic cue
                let grad = ctx.createRadialGradient(x-r*0.4, y-r*0.4, r*0.2, x, y, r);
                grad.addColorStop(0, '#ffffff');
                grad.addColorStop(0.4, '#d0d0d0');
                grad.addColorStop(1, '#7f7f7f');
                ctx.fillStyle = grad;
            } else if (material.startsWith('diamond_')) {
                let grad = ctx.createRadialGradient(x-r*0.5, y-r*0.5, r*0.1, x, y, r);
                grad.addColorStop(0, 'rgba(255,255,255,0.9)');
                grad.addColorStop(0.4, 'rgba(230,230,255,0.7)');
                grad.addColorStop(1, 'rgba(180,190,255,0.2)');
                ctx.fillStyle = grad;
            } else if (material.startsWith('stone_')) {
                let grad = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.2, x, y, r);
                grad.addColorStop(0, '#e0e0e0');
                grad.addColorStop(1, '#8b8b8b');
                ctx.fillStyle = grad;
            } else {
                // classic / plastic
            let grad = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.2, x, y, r);
            grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#ccc');
                ctx.fillStyle = grad;
            }
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            return;
        }

        // Generic helpers for materials
        const drawSolidClassic = () => {
            let grad = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.2, x, y, r);
            grad.addColorStop(0, adjustBrightness(this.color, 60));
            grad.addColorStop(0.3, this.color);
            grad.addColorStop(1, adjustBrightness(this.color, -50));
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
        };
        const drawStripeClassic = () => {
            // dark base
            ctx.fillStyle = "#111";
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            // central horizontal band
            ctx.save();
            ctx.beginPath();
            ctx.rect(x - r, y - r*0.45, r*2, r*0.9);
            ctx.clip();
            let bandGrad = ctx.createLinearGradient(x - r, y, x + r, y);
            bandGrad.addColorStop(0, adjustBrightness(this.color, 40));
            bandGrad.addColorStop(0.5, this.color);
            bandGrad.addColorStop(1, adjustBrightness(this.color, -20));
            ctx.fillStyle = bandGrad;
            ctx.beginPath(); ctx.arc(x, y, r*0.95, 0, Math.PI*2); ctx.fill();
            ctx.restore();
            // subtle glare
            let glare = ctx.createLinearGradient(x-r, y-r, x+r, y+r);
            glare.addColorStop(0, "rgba(255,255,255,0.4)"); glare.addColorStop(0.5, "rgba(255,255,255,0)");
            ctx.fillStyle = glare; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
        };

        const drawMetal = () => {
            let base = this.type === TYPE.BLACK ? '#222' : this.color;
            let grad = ctx.createLinearGradient(x-r, y-r, x+r, y+r);
            grad.addColorStop(0, adjustBrightness(base, 60));
            grad.addColorStop(0.25, base);
            grad.addColorStop(0.5, adjustBrightness(base, -20));
            grad.addColorStop(0.75, adjustBrightness(base, 40));
            grad.addColorStop(1, adjustBrightness(base, -40));
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            // specular streak
            ctx.strokeStyle = "rgba(255,255,255,0.6)";
            ctx.lineWidth = r * 0.18;
            ctx.beginPath();
            ctx.arc(x, y, r*0.65, -0.6, 0.4);
            ctx.stroke();
        };

        const drawDiamond = () => {
            let grad = ctx.createRadialGradient(x-r*0.4, y-r*0.4, r*0.1, x, y, r);
            grad.addColorStop(0, "rgba(255,255,255,0.95)");
            grad.addColorStop(0.3, adjustBrightness(this.color, 40));
            grad.addColorStop(0.7, this.color);
            grad.addColorStop(1, "rgba(10,10,20,0.9)");
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            // simple facet lines
            ctx.strokeStyle = "rgba(255,255,255,0.4)";
            ctx.lineWidth = 0.7;
            ctx.beginPath();
            ctx.moveTo(x-r*0.3, y);
            ctx.lineTo(x, y-r*0.4);
            ctx.lineTo(x+r*0.3, y);
            ctx.lineTo(x, y+r*0.4);
            ctx.closePath();
            ctx.stroke();
        };

        const drawStone = () => {
            let base = this.type === TYPE.BLACK ? '#1a1a1a' : this.color;
            let grad = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.2, x, y, r);
            grad.addColorStop(0, adjustBrightness(base, 30));
            grad.addColorStop(1, adjustBrightness(base, -30));
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            // speckle effect
            ctx.fillStyle = "rgba(255,255,255,0.15)";
            for (let i = 0; i < 6; i++) {
                let angle = Math.random() * Math.PI * 2;
                let rr = Math.random() * r*0.7;
                ctx.beginPath();
                ctx.arc(x + Math.cos(angle)*rr, y + Math.sin(angle)*rr, r*0.1, 0, Math.PI*2);
                ctx.fill();
            }
        };

        if (this.type === TYPE.BLACK) {
            if (material.startsWith('metal_')) {
                drawMetal();
            } else if (material.startsWith('diamond_')) {
                // black diamond uses dark tinted gradient
                let grad = ctx.createRadialGradient(x-r*0.4, y-r*0.4, r*0.1, x, y, r);
                grad.addColorStop(0, "rgba(255,255,255,0.8)");
                grad.addColorStop(0.3, "#444");
                grad.addColorStop(1, "#000");
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            } else if (material.startsWith('stone_')) {
                drawStone();
            } else {
                let grad = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.2, x, y, r);
                grad.addColorStop(0, '#444'); grad.addColorStop(1, '#000');
                ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            }
            // 8 label
            ctx.fillStyle = "#fff"; ctx.font = "bold 10px Inter";
            ctx.textAlign = "center"; ctx.textBaseline="middle"; ctx.fillText("8", x, y+0.5);
        } else if (this.type === TYPE.SOLID) {
            if (material.startsWith('metal_')) {
                drawMetal();
            } else if (material.startsWith('diamond_')) {
                drawDiamond();
            } else if (material.startsWith('stone_')) {
                drawStone();
            } else {
                drawSolidClassic();
            }
        } else if (this.type === TYPE.STRIPE) {
            if (material.startsWith('metal_')) {
                // metallic base with clear colored band
                ctx.fillStyle = "#050509"; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
                ctx.save();
                ctx.beginPath();
                ctx.rect(x - r, y - r*0.45, r*2, r*0.9);
                ctx.clip();
                let bandGrad = ctx.createLinearGradient(x - r, y, x + r, y);
                bandGrad.addColorStop(0, adjustBrightness(this.color, 50));
                bandGrad.addColorStop(0.5, this.color);
                bandGrad.addColorStop(1, adjustBrightness(this.color, -10));
                ctx.fillStyle = bandGrad;
                ctx.beginPath(); ctx.arc(x, y, r*0.96, 0, Math.PI*2); ctx.fill();
                ctx.restore();
                let glare = ctx.createLinearGradient(x-r, y-r, x+r, y+r);
                glare.addColorStop(0, "rgba(255,255,255,0.55)"); glare.addColorStop(0.5, "rgba(255,255,255,0)");
                ctx.fillStyle = glare; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            } else if (material.startsWith('diamond_')) {
                // dark crystal base with luminous band
                ctx.fillStyle = "rgba(8,8,18,0.98)"; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
                ctx.save();
                ctx.beginPath();
                ctx.rect(x - r, y - r*0.45, r*2, r*0.9);
                ctx.clip();
                let bandGrad = ctx.createLinearGradient(x - r, y, x + r, y);
                bandGrad.addColorStop(0, "rgba(255,255,255,0.9)");
                bandGrad.addColorStop(0.4, adjustBrightness(this.color, 40));
                bandGrad.addColorStop(1, this.color);
                ctx.fillStyle = bandGrad;
                ctx.beginPath(); ctx.arc(x, y, r*0.95, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            } else if (material.startsWith('stone_')) {
                // stone ball with carved band
                drawStone();
                ctx.save();
                ctx.beginPath();
                ctx.rect(x - r, y - r*0.4, r*2, r*0.8);
                ctx.clip();
                ctx.fillStyle = adjustBrightness(this.color, 20);
                ctx.globalAlpha = 0.7;
                ctx.beginPath(); ctx.arc(x, y, r*0.9, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            } else {
                drawStripeClassic();
            }
        }
    }
}

// --- Globals ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const trailCanvas = document.createElement('canvas');
const trailCtx = trailCanvas.getContext('2d');

const uiP1 = document.getElementById('p1-card');
const uiP2 = document.getElementById('p2-card');
const uiType1 = document.getElementById('p1-type');
const uiType2 = document.getElementById('p2-type');
const uiPowerControl = document.getElementById('power-control');
const uiPowerFill = document.getElementById('power-fill');
const uiPowerHandle = document.getElementById('power-handle');
const uiToast = document.getElementById('game-toast');
const uiMobileControls = document.getElementById('mobile-controls');
const uiDesktopHint = document.getElementById('desktop-hint');
const uiSettingsToggle = document.getElementById('settings-toggle');
const uiSettingsPanel = document.getElementById('settings-panel');
const uiCloseSettings = document.getElementById('close-settings');
const uiBallRange = document.getElementById('ball-size-input');
const uiPocketRange = document.getElementById('pocket-size-input');
const uiFeltSelect = document.getElementById('felt-select');
const uiApplySettings = document.getElementById('apply-settings');
const uiBallDisplay = document.getElementById('ball-size-display');
const uiPocketDisplay = document.getElementById('pocket-size-display');
const uiPowerMaxRange = document.getElementById('power-max-input');
const uiPowerMaxDisplay = document.getElementById('power-max-display');
const uiFrictionRange = document.getElementById('friction-input');
const uiFrictionDisplay = document.getElementById('friction-display');
const uiScore1 = document.getElementById('p1-score');
const uiScore2 = document.getElementById('p2-score');
const uiBallHandBanner = document.getElementById('ball-hand-banner');
const uiEndScreen = document.getElementById('end-screen');
const uiEndMessage = document.getElementById('end-message');
const uiRestartBtn = document.getElementById('restart-btn');
const uiBallMaterialSelect = document.getElementById('ball-material-select');
const uiAdvancedAimToggle = document.getElementById('advanced-aim-toggle');

if (uiRestartBtn) {
    uiRestartBtn.addEventListener('click', () => {
        hideEndScreen();
        resetGame();
    });
}

let logicalWidth, logicalHeight;
let balls = [];
let pockets = [];
let whiteBall;
let aimTouchStart = null;
let aimAngleStart = 0;
let placingBall = false;
let lastPlacementValid = false;

// --- Init ---
function resize() {
    const dpr = window.devicePixelRatio || 1;
    logicalWidth = window.innerWidth;
    logicalHeight = window.innerHeight;
    canvas.width = logicalWidth * dpr; canvas.height = logicalHeight * dpr;
    canvas.style.width = logicalWidth + "px"; canvas.style.height = logicalHeight + "px";
    ctx.resetTransform(); ctx.scale(dpr, dpr);
    trailCanvas.width = logicalWidth * dpr; trailCanvas.height = logicalHeight * dpr;
    trailCtx.resetTransform(); trailCtx.scale(dpr, dpr);
    const off = CONFIG.CUSHION_SIZE * 0.8;
    pockets = [
        new Vector(off, off), new Vector(logicalWidth/2, off-4), new Vector(logicalWidth-off, off),
        new Vector(off, logicalHeight-off), new Vector(logicalWidth/2, logicalHeight-off+4), new Vector(logicalWidth-off, logicalHeight-off)
    ];
}

function init() {
    resize();
    window.addEventListener('resize', resize);
    resetGame();
    setupInputs();
    setupSettingsPanel();
    requestAnimationFrame(loop);
}

function isInPowerBarArea(pos) {
    const c = CONFIG.CUSHION_SIZE;
    const barWidth = c;
    return pos.x >= logicalWidth - barWidth && pos.x <= logicalWidth &&
           pos.y >= c && pos.y <= logicalHeight - c;
}

function setupInputs() {
    // Canvas Touch / Mouse: decide between aim vs power by position
    canvas.addEventListener('touchstart', e => {
        STATE.inputType = 'touch'; updateDeviceUI();
        const pos = getEventPos(e);
        if (isInPowerBarArea(pos)) {
            handlePowerStart(e);
        } else {
        handleAimStart(e);
        }
    }, {passive: false});
    window.addEventListener('touchmove', e => {
        if (STATE.isCharging) {
            handlePowerMove(e);
        } else {
            handleAimMove(e);
        }
    }, {passive: false});
    
    // Mouse Aim / Power
    canvas.addEventListener('mousedown', e => {
        STATE.inputType = 'mouse'; updateDeviceUI();
        const pos = getEventPos(e);
        if (isInPowerBarArea(pos)) {
            handlePowerStart(e);
        } else {
        handleAimStart(e);
        }
    });
    window.addEventListener('mousemove', e => {
        STATE.inputType = 'mouse'; updateDeviceUI();
        if (STATE.isCharging) {
            handlePowerMove(e);
        } else {
        handleAimMove(e);
        }
    });

    // Mobile Fine Tune Buttons
    const btnLeft = document.getElementById('btn-left');
    const btnRight = document.getElementById('btn-right');
    const fineTune = (dir) => {
        if(!STATE.canShoot) return;
        STATE.aimAngle += dir * 0.05; // Small step
        if(navigator.vibrate) navigator.vibrate(5);
    };
    btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); fineTune(-1); });
    btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); fineTune(1); });
    // Also support click for testing
    btnLeft.addEventListener('mousedown', (e) => { e.preventDefault(); fineTune(-1); });
    btnRight.addEventListener('mousedown', (e) => { e.preventDefault(); fineTune(1); });

    window.addEventListener('mouseup', handlePowerEnd);
    window.addEventListener('mouseup', handlePlacementEnd);
    window.addEventListener('touchend', handlePowerEnd);
    window.addEventListener('touchend', handlePlacementEnd);

    // Keyboard
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    window.addEventListener('wheel', handleWheel); // Mouse wheel support
}

function setupSettingsPanel() {
    if (!uiSettingsToggle) return;
    uiBallRange.value = CONFIG.BALL_RADIUS;
    uiPocketRange.value = CONFIG.POCKET_RADIUS;
    uiBallDisplay.innerText = `${CONFIG.BALL_RADIUS}px`;
    uiPocketDisplay.innerText = `${CONFIG.POCKET_RADIUS}px`;
    uiFeltSelect.value = SETTINGS.feltScheme;
    if (uiBallMaterialSelect) uiBallMaterialSelect.value = SETTINGS.ballMaterial;
    uiPowerMaxRange.value = CONFIG.MAX_POWER;
    uiPowerMaxDisplay.innerText = `${CONFIG.MAX_POWER}`;
    uiFrictionRange.value = CONFIG.FRICTION.toFixed(3);
    uiFrictionDisplay.innerText = CONFIG.FRICTION.toFixed(3);
    if (uiAdvancedAimToggle) uiAdvancedAimToggle.checked = SETTINGS.advancedAim;

    const togglePanel = (show) => {
        uiSettingsPanel.classList[show ? 'add' : 'remove']('visible');
    };

    uiSettingsToggle.addEventListener('click', () => togglePanel(!uiSettingsPanel.classList.contains('visible')));
    uiCloseSettings.addEventListener('click', () => togglePanel(false));

    uiBallRange.addEventListener('input', () => {
        SETTINGS.ballRadius = Number(uiBallRange.value);
        uiBallDisplay.innerText = `${SETTINGS.ballRadius}px`;
    });
    uiPocketRange.addEventListener('input', () => {
        SETTINGS.pocketRadius = Number(uiPocketRange.value);
        uiPocketDisplay.innerText = `${SETTINGS.pocketRadius}px`;
    });
    uiFeltSelect.addEventListener('change', () => {
        SETTINGS.feltScheme = uiFeltSelect.value;
    });
    if (uiBallMaterialSelect) {
        uiBallMaterialSelect.addEventListener('change', () => {
            SETTINGS.ballMaterial = uiBallMaterialSelect.value;
        });
    }
    uiPowerMaxRange.addEventListener('input', () => {
        SETTINGS.maxPower = Number(uiPowerMaxRange.value);
        uiPowerMaxDisplay.innerText = `${SETTINGS.maxPower}`;
    });
    uiFrictionRange.addEventListener('input', () => {
        SETTINGS.friction = Number(uiFrictionRange.value);
        uiFrictionDisplay.innerText = SETTINGS.friction.toFixed(3);
    });

    if (uiAdvancedAimToggle) {
        uiAdvancedAimToggle.addEventListener('change', () => {
            SETTINGS.advancedAim = !!uiAdvancedAimToggle.checked;
        });
    }

    // +/- buttons for easier tap control
    const spinButtons = document.querySelectorAll('.spin-btn');
    spinButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.preventDefault();
            const targetId = btn.getAttribute('data-target');
            const step = Number(btn.getAttribute('data-step') || '1');
            const min = Number(btn.getAttribute('data-min') || '-999999');
            const max = Number(btn.getAttribute('data-max') || '999999');
            const dir = btn.textContent.trim() === '+' ? 1 : -1;
            const input = document.getElementById(targetId);
            if (!input) return;
            let current = Number(input.value || input.getAttribute('value') || 0);
            if (isNaN(current)) current = 0;
            let next = current + dir * step;
            if (next < min) next = min;
            if (next > max) next = max;
            input.value = String(next);
            // trigger original input handlers so UI text & SETTINGS are updated
            const ev = new Event('input', { bubbles: true });
            input.dispatchEvent(ev);
        });
    });

    uiApplySettings.addEventListener('click', () => {
        applyCustomSettings();
        togglePanel(false);
    });
}

function applyCustomSettings() {
    CONFIG.BALL_RADIUS = SETTINGS.ballRadius;
    CONFIG.POCKET_RADIUS = SETTINGS.pocketRadius;
    PALETTE.FELT = FELT_SCHEMES[SETTINGS.feltScheme] || FELT_SCHEMES.midnight;
    CONFIG.POWER_SCALE = BASE_CONFIG.POWER_SCALE * (BASE_CONFIG.BALL_RADIUS / CONFIG.BALL_RADIUS);
    CONFIG.MAX_POWER = SETTINGS.maxPower;
    CONFIG.FRICTION = SETTINGS.friction;
    STATE.ballMaterial = SETTINGS.ballMaterial || 'classic';
     STATE.advancedAim = !!SETTINGS.advancedAim;
    showToast("Settings applied — new rack ready");
    resetGame();
}

function updateDeviceUI() {
    if (STATE.inputType === 'touch') {
        uiMobileControls.style.display = 'flex';
        uiDesktopHint.style.display = 'none';
    } else {
        uiMobileControls.style.display = 'none';
        uiDesktopHint.style.display = 'block';
    }
}

// --- Input Handlers ---
function handleAimStart(e) {
    if (STATE.gameOver) return;
    if (STATE.ballInHand && STATE.canShoot) {
        e.preventDefault();
        placingBall = true;
        attemptPlaceCueBall(getEventPos(e));
        return;
    }
    if (!STATE.canShoot || STATE.spaceCharging) return;
    if (e.target !== canvas) return;
    e.preventDefault();
    aimTouchStart = getEventPos(e);
    aimAngleStart = STATE.aimAngle;
}

function handleAimMove(e) {
    if (STATE.gameOver) return;
    if (STATE.ballInHand && placingBall) {
        e.preventDefault();
        attemptPlaceCueBall(getEventPos(e));
        return;
    }
    if (!STATE.canShoot || STATE.isCharging || STATE.spaceCharging) return;
    const pos = getEventPos(e);

    if (STATE.inputType === 'mouse') {
        // Mouse aims along the cue ball to cursor vector
        const angle = Math.atan2(pos.y - whiteBall.pos.y, pos.x - whiteBall.pos.x);
        if (!isNaN(angle)) STATE.aimAngle = angle;
        return;
    }

    if (!aimTouchStart) return;
    let dy = pos.y - aimTouchStart.y;
    let sensitivity = CONFIG.AIM_SENSITIVITY_TOUCH;
    STATE.aimAngle = aimAngleStart + (dy * sensitivity); 
}

function handleKeyDown(e) {
    if (!STATE.canShoot || STATE.gameOver) return;
    STATE.inputType = 'mouse'; updateDeviceUI();
    
    const step = e.shiftKey ? 0.05 : 0.005; // Shift for fast turn

    if (e.code === 'ArrowLeft') STATE.aimAngle -= step;
    if (e.code === 'ArrowRight') STATE.aimAngle += step;
    
    if (e.code === 'Space' && !STATE.spaceCharging && !e.repeat) {
        STATE.spaceCharging = true;
        STATE.power = 0;
        STATE.spaceChargeDir = 1;
    }
}

function handleKeyUp(e) {
    if (STATE.gameOver) return;
    if (e.code === 'Space' && STATE.spaceCharging) {
        STATE.spaceCharging = false;
        shoot();
        STATE.power = 0;
        updatePowerUI(0);
    }
}

function handleWheel(e) {
    if (!STATE.canShoot || STATE.ballInHand || STATE.gameOver) return;
    STATE.aimAngle += e.deltaY * 0.001;
}

// Power Slider Logic
function handlePowerStart(e) {
    if (!STATE.canShoot || STATE.spaceCharging || STATE.ballInHand || STATE.gameOver) return;
    e.preventDefault();
    STATE.isCharging = true;
    updatePowerUI(0);
}

function handlePowerMove(e) {
    if (!STATE.isCharging) return;
    const pos = getEventPos(e);
    const c = CONFIG.CUSHION_SIZE;
    const top = c;
    const bottom = logicalHeight - c;
    // vertical bar on right cushion: from bottom (0) to top (1)
    let t = (bottom - pos.y) / (bottom - top);
    let percent = Math.max(0, Math.min(1, t));
    STATE.power = percent;
    updatePowerUI(percent);
}

function handlePowerEnd(e) {
    if (!STATE.isCharging) return;
    STATE.isCharging = false;
    if (STATE.power > 0.1) shoot();
    STATE.power = 0;
    updatePowerUI(0);
}

function getEventPos(e) {
    if (e.touches && e.touches.length > 0) return new Vector(e.touches[0].clientX, e.touches[0].clientY);
    return new Vector(e.clientX, e.clientY);
}

function clampToTableBounds(pos) {
    const bound = CONFIG.CUSHION_SIZE + CONFIG.BALL_RADIUS;
    const x = Math.max(bound, Math.min(logicalWidth - bound, pos.x));
    const y = Math.max(bound, Math.min(logicalHeight - bound, pos.y));
    return new Vector(x, y);
}

function isPlacementValid(pos) {
    for (let b of balls) {
        if (b === whiteBall || !b.active) continue;
        if (pos.dist(b.pos) < CONFIG.BALL_RADIUS * 2) return false;
    }
    return true;
}

function attemptPlaceCueBall(rawPos) {
    if (!rawPos) return false;
    const bounded = clampToTableBounds(rawPos);
    if (!isPlacementValid(bounded)) {
        if (!placingBall) showToast("Cue ball overlaps another ball");
        lastPlacementValid = false;
        return false;
    }
    whiteBall.active = true;
    whiteBall.pos = bounded;
    whiteBall.vel = new Vector(0,0);
    lastPlacementValid = true;
    return true;
}

function handlePlacementEnd() {
    if (!STATE.ballInHand || !placingBall) return;
    placingBall = false;
    if (lastPlacementValid) {
        STATE.ballInHand = false;
        updateBallInHandBanner();
        showToast("Cue ball locked in");
    } else {
        updateBallInHandBanner();
        showToast("Pick a legal spot");
    }
}

// --- Logic ---
function updatePowerUI(percent) {
    // Legacy DOM slider is hidden; logic now rendered into bottom cushion via canvas
}

function shoot() {
    if (STATE.ballInHand || STATE.gameOver) return;
    hideToast();
    STATE.shotCount += 1;
    STATE.canShoot = false;
    let force = STATE.power * CONFIG.MAX_POWER;
    let dir = new Vector(Math.cos(STATE.aimAngle), Math.sin(STATE.aimAngle));
    whiteBall.vel = dir.mult(force * CONFIG.POWER_SCALE);
    STATE.sunkThisTurn = [];
    STATE.foul = false;
    if(navigator.vibrate) navigator.vibrate(20); // haptic feedback
}

function resetGame() {
    hideEndScreen();
    hideToast();
    balls = [];
    STATE.turn = 1; STATE.assigned = false; STATE.p1Group = null;
    STATE.foul = false; STATE.gameOver = false; STATE.sunkThisTurn = [];
    STATE.canShoot = true;
    STATE.ballInHand = false; placingBall = false; lastPlacementValid = false;
    STATE.scores = {1: 0, 2: 0};
    STATE.shotCount = 0;
    STATE.power = 0;
    STATE.isCharging = false;
    STATE.spaceCharging = false;
    STATE.spaceChargeDir = 1;
    STATE.inputType = 'unknown';
    updateBallInHandBanner();
    trailCtx.clearRect(0,0,logicalWidth,logicalHeight);

    whiteBall = new Ball(logicalWidth * 0.25, logicalHeight / 2, TYPE.CUE, '#fff', 0);
    balls.push(whiteBall);

    const startX = logicalWidth * 0.7;
    const startY = logicalHeight / 2;
    const r = CONFIG.BALL_RADIUS;
    const rackPattern = [1, 1, 0, 0, 2, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0]; 
    let solids = [...PALETTE.SOLIDS], stripes = [...PALETTE.STRIPES];
    let ballIdx = 0;

    for (let col = 0; col < 5; col++) {
        for (let row = 0; row <= col; row++) {
            let x = startX + col * (r * 2 * 0.866 + 1);
            let y = startY - col * (r + 0.5) + row * (r * 2 + 1);
            let typeCode = rackPattern[ballIdx];
            let type, color, id;
            if (typeCode === 2) { type = TYPE.BLACK; color = '#000'; id = 8; }
            else if (typeCode === 0) { type = TYPE.SOLID; color = solids.shift()||'#888'; id=ballIdx+1; }
            else { type = TYPE.STRIPE; color = stripes.shift()||'#888'; id=ballIdx+9; }
            balls.push(new Ball(x, y, type, color, id));
            ballIdx++;
        }
    }
    updateUI();
    updatePowerUI(0);
    showToast("GAME START");
}

function checkTurn() {
    const isMoving = balls.some(b => b.active && b.vel.mag() > CONFIG.STOP_VELOCITY);
    if (!isMoving && !STATE.canShoot && !STATE.gameOver) {
        resolveTurn();
        STATE.canShoot = true;
    }
}

function resolveTurn() {
    let switchTurn = true;
    let message = "";

    const sunkBlack = STATE.sunkThisTurn.includes(TYPE.BLACK);
    const cueScratch = STATE.foul;

    // Black ball logic takes highest priority
    if (sunkBlack) {
        const isBreakShot = (STATE.shotCount === 1 && !STATE.assigned);
        if (isBreakShot && !cueScratch) {
            // Clean break pot on black: immediate win for breaker
            message = `PLAYER ${STATE.turn} WINS! (break pot)`;
        } else {
            let myType = (STATE.turn === 1)
                ? STATE.p1Group
                : (STATE.p1Group === TYPE.SOLID ? TYPE.STRIPE : TYPE.SOLID);
            let myRemaining = countRemaining(myType);
            // If player still has group balls left OR groups not assigned OR cue scratched with black → loss
            if (myRemaining > 0 || !STATE.assigned || cueScratch) {
                message = `PLAYER ${STATE.turn} LOST`;
            } else {
                message = `PLAYER ${STATE.turn} WINS!`;
            }
        }
        STATE.gameOver = true;
        STATE.canShoot = false;
        showToast(message);
        showEndScreen(message);
        return;
    }

    if (STATE.foul) {
        message = "FOUL! BALL IN HAND";
        resetWhiteBall(true);
        switchTurn = true;
    } else if (STATE.sunkThisTurn.length > 0) {
        let firstSunk = STATE.sunkThisTurn[0];
        if (!STATE.assigned) {
            // First legal object ball of the game: lock in groups based on shooter
            if (firstSunk === TYPE.SOLID || firstSunk === TYPE.STRIPE) {
                if (STATE.turn === 1) {
                    // Shooter is P1: P1 gets what they potted
                    STATE.p1Group = firstSunk;
                } else {
                    // Shooter is P2: P1 gets the opposite group
                    STATE.p1Group = (firstSunk === TYPE.SOLID ? TYPE.STRIPE : TYPE.SOLID);
                }
                STATE.assigned = true;
                const p1IsSolids = STATE.p1Group === TYPE.SOLID;
                message = p1IsSolids
                    ? "Groups set: P1 solids / P2 stripes"
                    : "Groups set: P1 stripes / P2 solids";
                // Shooter continues after a good opening pot
                switchTurn = false;
            }
        } else {
            let myGroup = (STATE.turn === 1) ? STATE.p1Group : (STATE.p1Group === TYPE.SOLID ? TYPE.STRIPE : TYPE.SOLID);
            if (STATE.sunkThisTurn.includes(myGroup)) { switchTurn = false; message = "GOOD SHOT"; }
            else { switchTurn = true; message = "WRONG BALL"; }
        }
    } else { switchTurn = true; }

    // Fallback: if somehow all object balls are gone, treat as rack finished (draw)
    const remainingSolids = countRemaining(TYPE.SOLID);
    const remainingStripes = countRemaining(TYPE.STRIPE);
    const remainingBlack = countRemaining(TYPE.BLACK);
    if (!STATE.gameOver && remainingSolids === 0 && remainingStripes === 0 && remainingBlack === 0) {
        const drawMsg = "Rack cleared — no balls remaining";
        STATE.gameOver = true;
        STATE.canShoot = false;
        showToast(drawMsg);
        showEndScreen(drawMsg);
        return;
    }

    if (switchTurn) STATE.turn = STATE.turn === 1 ? 2 : 1;
    if (message) showToast(message);
    updateUI();
    updateBallInHandBanner();
}

function countRemaining(type) { return type ? balls.filter(b => b.active && b.type === type).length : 0; }
function resetWhiteBall(withBallInHand = false) {
    whiteBall.active = true; whiteBall.vel = new Vector(0,0);
    whiteBall.pos = new Vector(logicalWidth * 0.25, logicalHeight / 2);
    STATE.ballInHand = withBallInHand;
    placingBall = false;
    lastPlacementValid = false;
    updateBallInHandBanner();
}

function resolveCollisions() {
    for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
            let b1 = balls[i]; let b2 = balls[j];
            if (!b1.active || !b2.active) continue;
            let dist = b1.pos.dist(b2.pos);
            if (dist < CONFIG.BALL_RADIUS * 2) {
                let normal = b2.pos.sub(b1.pos).normalize();
                let overlap = CONFIG.BALL_RADIUS * 2 - dist;
                b1.pos = b1.pos.sub(normal.mult(overlap * 0.5));
                b2.pos = b2.pos.add(normal.mult(overlap * 0.5));
                let relVel = b1.vel.sub(b2.vel);
                let sepVel = Vector.dot(relVel, normal);
                let newSepVel = -sepVel * CONFIG.BALL_BOUNCE;
                let sepVelVec = normal.mult(newSepVel - sepVel);
                b1.vel = b1.vel.add(sepVelVec.mult(0.5));
                b2.vel = b2.vel.sub(sepVelVec.mult(0.5));
            }
        }
    }
    for (let b of balls) {
        if (!b.active) continue;
        for (let p of pockets) {
            if (b.pos.dist(p) < CONFIG.POCKET_RADIUS) {
                if (b.type === TYPE.CUE) { STATE.foul = true; b.active = false; }
                else {
                    b.active = false; b.vel = new Vector(0,0);
                    STATE.sunkThisTurn.push(b.type);
                    STATE.scores[STATE.turn] = (STATE.scores[STATE.turn] || 0) + 1;
                    spawnFloatText("+1", p.x, p.y);
                    updateUI();
                }
            }
        }
    }
}

function spawnFloatText(text, x, y) {
    const el = document.createElement('div');
    el.className = 'float-text'; el.innerText = text;
    el.style.left = Math.min(x, logicalWidth-50)+'px'; el.style.top = Math.min(y, logicalHeight-50)+'px';
    document.body.appendChild(el); setTimeout(() => el.remove(), 800);
}
function showToast(msg) {
    if (!uiToast) return;
    uiToast.innerText = msg;
    uiToast.style.opacity = "1";
    setTimeout(() => {
        // 防止在新消息刚显示时被旧定时器误关掉
        if (uiToast.innerText === msg) {
            uiToast.style.opacity = "0";
        }
    }, 2000);
}
function hideToast() {
    if (uiToast) uiToast.style.opacity = "0";
}
function updateBallInHandBanner() {
    if (!uiBallHandBanner) return;
    if (STATE.ballInHand && !STATE.gameOver) {
        uiBallHandBanner.innerText = `Ball in hand — Player ${STATE.turn}, drag the cue ball to place it.`;
        uiBallHandBanner.classList.add('visible');
    } else {
        uiBallHandBanner.classList.remove('visible');
    }
}
function showEndScreen(msg) {
    if (uiEndMessage) uiEndMessage.innerText = msg;
    if (uiEndScreen) uiEndScreen.classList.add('visible');
    updateBallInHandBanner();
}
function hideEndScreen() {
    if (uiEndScreen) uiEndScreen.classList.remove('visible');
}
function updateUI() {
    if (STATE.turn === 1) { uiP1.classList.add('active', 'p1-active'); uiP2.classList.remove('active', 'p2-active'); }
    else { uiP1.classList.remove('active', 'p1-active'); uiP2.classList.add('active', 'p2-active'); }
    if (!STATE.assigned) { uiType1.innerText = "ANY"; uiType2.innerText = "ANY"; }
    else {
        uiType1.innerText = STATE.p1Group === TYPE.SOLID ? "SOLIDS ●" : "STRIPES ◎";
        uiType2.innerText = STATE.p1Group === TYPE.SOLID ? "STRIPES ◎" : "SOLIDS ●";
    }
    if (uiScore1) uiScore1.innerText = STATE.scores[1];
    if (uiScore2) uiScore2.innerText = STATE.scores[2];
}

function buildTargetsForPlayer(isP1) {
    if (!STATE.assigned) return [];
    const myGroup = isP1 ? STATE.p1Group : (STATE.p1Group === TYPE.SOLID ? TYPE.STRIPE : TYPE.SOLID);
    if (myGroup !== TYPE.SOLID && myGroup !== TYPE.STRIPE) return [];

    // All balls that originally belong to this group (by type), excluding black/cue
    const groupBalls = balls
        .filter(b => b.type === myGroup && typeof b.id === 'number' && b.id !== 8)
        .sort((a, b) => (a.id || 0) - (b.id || 0));

    const remainingCount = groupBalls.filter(b => b.active).length;

    // 如果己方目标球都清空，且黑球仍在台面，则目标只剩黑球
    const blackRemaining = countRemaining(TYPE.BLACK) > 0;
    if (remainingCount === 0 && blackRemaining) {
        return [{ id: 8, isRemaining: true, isBlack: true, color: '#000' }];
    }

    return groupBalls.map(b => ({
        id: b.id,
        isRemaining: b.active,
        isBlack: false,
        color: b.color
    }));
}

function drawScoreboard(ctx) {
    const c = CONFIG.CUSHION_SIZE;
    const y = c + 24;
    const cardWidth = 150;
    const cardHeight = 44;
    const gap = 18;
    const centerX = logicalWidth / 2;
    const p1x = centerX - cardWidth - gap/2;
    const p2x = centerX + gap/2;

    const drawCard = (x, label, targets, isActive, isP1) => {
        ctx.save();
        const cardRadius = 12;

        // background
        ctx.beginPath();
        ctx.moveTo(x + cardRadius, y);
        ctx.lineTo(x + cardWidth - cardRadius, y);
        ctx.quadraticCurveTo(x + cardWidth, y, x + cardWidth, y + cardRadius);
        ctx.lineTo(x + cardWidth, y + cardHeight - cardRadius);
        ctx.quadraticCurveTo(x + cardWidth, y + cardHeight, x + cardWidth - cardRadius, y + cardHeight);
        ctx.lineTo(x + cardRadius, y + cardHeight);
        ctx.quadraticCurveTo(x, y + cardHeight, x, y + cardHeight - cardRadius);
        ctx.lineTo(x, y + cardRadius);
        ctx.quadraticCurveTo(x, y, x + cardRadius, y);

        const base = "rgba(15,15,25,0.86)";
        ctx.fillStyle = base;
        ctx.fill();
        ctx.strokeStyle = isActive ? "rgba(255,255,255,0.35)" : "rgba(255,255,255,0.15)";
        ctx.lineWidth = isActive ? 2 : 1;
        ctx.stroke();

        // group text
        ctx.font = "10px Inter";
        ctx.textBaseline = "top";
        ctx.textAlign = "left";
        ctx.fillStyle = isP1 ? PALETTE.P1_COLOR : PALETTE.P2_COLOR;
        ctx.fillText(label, x + 10, y + 6);

        // target balls row
        const rowY = y + 20;
        const maxPerRow = 8;
        const dotRadius = 7;
        const spacing = 4 + dotRadius*2;
        const startX = x + 12;

        if (targets && targets.length) {
            ctx.font = "9px Inter";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            let idx = 0;
            for (let t of targets) {
                if (idx >= maxPerRow) break;
                const cx = startX + idx * spacing;
                const cy = rowY;
                const isRem = t.isRemaining;

                ctx.beginPath();
                if (t.isBlack || t.id === 8) {
                    ctx.fillStyle = isRem ? "#000" : "rgba(50,50,50,0.9)";
                } else if (isRem) {
                    ctx.fillStyle = t.color || (isP1 ? PALETTE.P1_COLOR : PALETTE.P2_COLOR);
                } else {
                    ctx.fillStyle = "rgba(80,80,90,0.9)"; // fully gray for potted balls
                }
                ctx.arc(cx, cy, dotRadius, 0, Math.PI*2);
                ctx.fill();

                ctx.strokeStyle = "rgba(0,0,0,0.4)";
                ctx.lineWidth = 0.8;
                ctx.stroke();

                // text label
                const textColor = isRem ? "#ffffff" : "rgba(180,180,190,0.9)";
                ctx.fillStyle = textColor;
                ctx.fillText(String(t.id), cx, cy+0.5);

                idx++;
            }
        }

        ctx.restore();
    };

    let p1Label = "ANY";
    let p2Label = "ANY";
    let p1Targets = [];
    let p2Targets = [];
    if (STATE.assigned) {
        const p1Solids = STATE.p1Group === TYPE.SOLID;
        p1Label = p1Solids ? "SOLIDS ●" : "STRIPES ◎";
        p2Label = p1Solids ? "STRIPES ◎" : "SOLIDS ●";
        p1Targets = buildTargetsForPlayer(true);
        p2Targets = buildTargetsForPlayer(false);
    }

    drawCard(p1x, p1Label, p1Targets, STATE.turn === 1, true);
    drawCard(p2x, p2Label, p2Targets, STATE.turn === 2, false);
}
function adjustBrightness(col, amt) {
    let usePound = false; if (col[0] == "#") { col = col.slice(1); usePound = true; }
    let num = parseInt(col,16); let r = (num >> 16) + amt; let b = ((num >> 8) & 0x00FF) + amt; let g = (num & 0x0000FF) + amt;
    r = r > 255 ? 255 : (r < 0 ? 0 : r); b = b > 255 ? 255 : (b < 0 ? 0 : b); g = g > 255 ? 255 : (g < 0 ? 0 : g);
    return (usePound?"#":"") + (g | (b << 8) | (r << 16)).toString(16).padStart(6,0);
}

function loop() {
    ctx.clearRect(0, 0, logicalWidth, logicalHeight);
    
    // Space Charging Logic
    if (STATE.spaceCharging) {
        STATE.power += 0.02 * STATE.spaceChargeDir;
        if (STATE.power >= 1) { STATE.power = 1; STATE.spaceChargeDir = -1; }
        if (STATE.power <= 0) { STATE.power = 0; STATE.spaceChargeDir = 1; }
        updatePowerUI(STATE.power);
    }

    trailCtx.globalCompositeOperation = 'destination-out';
    trailCtx.fillStyle = `rgba(0, 0, 0, ${CONFIG.TRAIL_FADE})`;
    trailCtx.fillRect(0, 0, logicalWidth, logicalHeight);
    trailCtx.globalCompositeOperation = 'source-over';

    let felt = ctx.createRadialGradient(logicalWidth/2, logicalHeight/2, logicalWidth*0.2, logicalWidth/2, logicalHeight/2, logicalWidth);
    felt.addColorStop(0, PALETTE.FELT[0]); felt.addColorStop(1, PALETTE.FELT[1]);
    ctx.fillStyle = felt; ctx.fillRect(0, 0, logicalWidth, logicalHeight);
    ctx.drawImage(trailCanvas, 0, 0, logicalWidth, logicalHeight);
    
    const c = CONFIG.CUSHION_SIZE;
    ctx.fillStyle = "#0a0a10";
    ctx.fillRect(0,0,logicalWidth,c); ctx.fillRect(0,logicalHeight-c,logicalWidth,c);
    ctx.fillRect(0,0,c,logicalHeight); ctx.fillRect(logicalWidth-c,0,c,logicalHeight);
    ctx.strokeStyle = "rgba(255,255,255,0.1)"; ctx.lineWidth=1;
    ctx.strokeRect(c,c,logicalWidth-c*2,logicalHeight-c*2);
    
    ctx.fillStyle = "#000";
    for(let p of pockets) { ctx.beginPath(); ctx.arc(p.x, p.y, CONFIG.POCKET_RADIUS, 0, Math.PI*2); ctx.fill(); }

    // Right-cushion vertical power bar (bright base)
    const barC = CONFIG.CUSHION_SIZE;
    const barWidth = 8;
    const barTop = barC + 16;
    const barBottom = logicalHeight - barC - 16;
    const barHeight = Math.max(0, barBottom - barTop);
    const barX = logicalWidth - barC + (barC - barWidth) * 0.5;

    ctx.save();
    // bright translucent base
    const baseGrad = ctx.createLinearGradient(barX, barTop, barX, barBottom);
    baseGrad.addColorStop(0, "rgba(255,255,255,0.65)");
    baseGrad.addColorStop(1, "rgba(230,230,230,0.65)");
    ctx.fillStyle = baseGrad;
    ctx.fillRect(barX, barTop, barWidth, barHeight);
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 1;
    ctx.strokeRect(barX+0.5, barTop+0.5, barWidth-1, barHeight-1);

    const pct = Math.max(0, Math.min(1, STATE.power || 0));
    if (pct > 0) {
        const color = STATE.turn === 1 ? PALETTE.P1_COLOR : PALETTE.P2_COLOR;
        const filled = barHeight * pct;
        const fillGrad = ctx.createLinearGradient(barX, barBottom, barX, barTop);
        fillGrad.addColorStop(0, adjustBrightness(color, -10));
        fillGrad.addColorStop(1, adjustBrightness(color, 40));
        ctx.fillStyle = fillGrad;
        ctx.fillRect(barX, barBottom - filled, barWidth, filled);
    }
    ctx.restore();

    // Draw embedded scoreboard on felt, below balls
    drawScoreboard(ctx);

    resolveCollisions();
    checkTurn();

    for(let b of balls) { b.update(); b.draw(ctx); }
    
    if (STATE.canShoot && !STATE.gameOver && !STATE.ballInHand) {
        const start = whiteBall.pos;
        const dir = new Vector(Math.cos(STATE.aimAngle), Math.sin(STATE.aimAngle)).normalize();
        const color = STATE.turn === 1 ? PALETTE.P1_COLOR : PALETTE.P2_COLOR;
        const maxDist = Math.max(logicalWidth, logicalHeight);

        // Find first collision with any active object ball (not cue)
        // using precise circle–ray intersection for equal-radius balls:
        // cue center moves along 'dir', object ball is a circle of radius 2R
        let hitBall = null;
        let hitDist = maxDist;
        const R = CONFIG.BALL_RADIUS * 2; // center-to-center distance at first contact
        for (let b of balls) {
            if (!b.active || b === whiteBall) continue;

            // Ray-sphere intersection: |(start + dir*t) - b.pos| = R
            const f = start.sub(b.pos);              // from ball center to cue center
            const a = 1;                             // dir is normalized
            const bCoef = 2 * Vector.dot(dir, f);
            const cTerm = f.mag() * f.mag() - R*R;
            const disc = bCoef*bCoef - 4*a*cTerm;
            if (disc < 0) continue;                  // no intersection

            const sqrtD = Math.sqrt(disc);
            let t1 = (-bCoef - sqrtD) / (2*a);
            let t2 = (-bCoef + sqrtD) / (2*a);

            // pick smallest positive t as first contact
            let tHit = Number.POSITIVE_INFINITY;
            if (t1 > 0 && t1 < tHit) tHit = t1;
            if (t2 > 0 && t2 < tHit) tHit = t2;
            if (!isFinite(tHit) || tHit <= 0 || tHit > maxDist) continue;

            if (tHit < hitDist) {
                hitDist = tHit;
                hitBall = b;
            }
        }

        const baseEnd = start.add(dir.mult(hitBall ? hitDist : maxDist * 0.9));

        // Soft outer halo around cue ball
        ctx.beginPath();
        ctx.arc(start.x, start.y, CONFIG.BALL_RADIUS + 16, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        ctx.lineWidth = 1;
        ctx.stroke();

        // Main aiming ray (long, faint dashed)
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(start.x + dir.x * maxDist, start.y + dir.y * maxDist);
        ctx.strokeStyle = "rgba(255,255,255,0.18)";
        ctx.lineWidth = 1.5;
        ctx.setLineDash([4, 10]);
        ctx.stroke();
        ctx.restore();

        if (hitBall) {
            // Solid segment up to first impact
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(baseEnd.x, baseEnd.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2.4;
            ctx.setLineDash([10, 4]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Mark expected contact point
            ctx.beginPath();
            ctx.arc(baseEnd.x, baseEnd.y, 4, 0, Math.PI*2);
            ctx.fillStyle = color;
            ctx.fill();

            if (STATE.advancedAim) {
                // Predict post-collision paths (simple equal-mass elastic model)
                // impact normal from cue impact point to object center
                const impactPoint = baseEnd;
                const n = hitBall.pos.sub(impactPoint).normalize();
                const v = dir; // cue ball incoming direction
                const vDotN = Vector.dot(v, n);

                // For very thin, "extreme" cuts the simple model is unreliable:
                // only show contact preview and skip post-collision guides.
                const approach = Math.abs(vDotN);

                // Object ball leaves roughly along impact normal
                const objDir = n;
                const objStart = hitBall.pos;
                const travelLen = CONFIG.BALL_RADIUS * 8;
                const objEnd = objStart.add(objDir.mult(travelLen));

                ctx.beginPath();
                ctx.moveTo(objStart.x, objStart.y);
                ctx.lineTo(objEnd.x, objEnd.y);
                ctx.strokeStyle = "rgba(255,255,255,0.45)";
                ctx.lineWidth = 1.6;
                ctx.setLineDash([3, 6]);
                ctx.stroke();
                ctx.setLineDash([]);

                // Cue ball loses its normal component, keeps tangential component
                if (approach >= 0.18) {
                    let cueDir = v.sub(n.mult(vDotN));
                    if (cueDir.mag() > 0.0001) {
                        cueDir = cueDir.normalize();
                    } else {
                        // fallback: slight reflection if nearly head-on
                        cueDir = v.sub(n.mult(2 * vDotN)).normalize();
                    }

                    const cueStart = impactPoint.add(cueDir.mult(CONFIG.BALL_RADIUS * 1.2));
                    const cueEnd = cueStart.add(cueDir.mult(travelLen));

                    ctx.beginPath();
                    ctx.moveTo(cueStart.x, cueStart.y);
                    ctx.lineTo(cueEnd.x, cueEnd.y);
                    ctx.strokeStyle = "rgba(255,255,255,0.35)";
                    ctx.lineWidth = 1.4;
                    ctx.setLineDash([2, 6]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
    }
    requestAnimationFrame(loop);
}

init();
</script>
</body>
</html>