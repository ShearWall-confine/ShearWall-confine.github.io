<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>曼巴狂奔跑道 | 致敬科比</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000; /* 初始为黑夜 */
            font-family: 'Helvetica Neue', Arial, sans-serif;
            touch-action: none;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 20;
        }
        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            color: #FDB927;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 2px 2px 0px #552583;
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(85, 37, 131, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 30;
        }
        h1 {
            color: #FDB927;
            font-size: 48px;
            margin-bottom: 10px;
            text-transform: uppercase;
            text-shadow: 3px 3px 0px #000;
            text-align: center;
        }
        p {
            color: white;
            font-size: 18px;
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.5;
        }
        button {
            background: #FDB927;
            color: #552583;
            border: 4px solid #fff;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 50px;
            transition: transform 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        button:hover {
            transform: scale(1.05);
            background: #ffcc4d;
        }
        button:active {
            transform: scale(0.95);
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            justify-content: center;
            width: 100%;
        }
        .secondary-btn {
            background: transparent;
            border: 2px solid rgba(255,255,255,0.6);
            color: #fff;
        }
        .secondary-btn:hover {
            background: rgba(255,255,255,0.15);
            color: #fff;
        }
        .hidden {
            display: none !important;
        }
        .instruction-key {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 2px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-display">分数: 0</div>
            <div>MAMBA FOREVER</div>
        </div>
    </div>

    <div id="start-screen">
        <h1>曼巴狂奔跑道</h1>
        <p>致敬传奇 - 凌晨4点的洛杉矶<br>收集篮球，躲避防守、跨栏和高墙</p>
        <p>
            <span class="instruction-key">↑</span> 跳跃 &nbsp; 
            <span class="instruction-key">↓</span> 滑铲 &nbsp; 
            <span class="instruction-key">←</span> <span class="instruction-key">→</span> 变道
        </p>
        <div class="button-group">
            <button id="start-btn">开始比赛</button>
            <button id="home-btn" class="secondary-btn">← 返回主界面</button>
        </div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>比赛结束</h1>
        <p id="final-score">得分: 0</p>
        <div class="button-group">
            <button id="restart-btn">再来一局</button>
            <button id="home-btn-over" class="secondary-btn">← 返回主界面</button>
        </div>
    </div>

    <script>
        // --- 游戏配置 ---
        const CONFIG = {
            laneWidth: 3,
            playerSpeedBase: 0.3, // 初始速度稍慢
            playerSpeedMax: 1.2, // 最大速度提高
            speedAcceleration: 0.00005, // 加速度
            jumpHeight: 4.2, // 跳得更高一点以越过障碍
            gravity: 0.2,
            colors: {
                purple: 0x552583,
                gold: 0xFDB927,
                floor: 0x222222,
                floorLine: 0xFFFFFF,
                obstacle: 0x8B0000, // 防守者红
                barrierLow: 0x333333, // 低栏架深灰
                barrierHigh: 0x555555 // 高墙浅灰
            }
        };

        // --- 变量 ---
        let scene, camera, renderer;
        let player, playerBodyGroup;
        // 身体部位，用于动画
        let leftLegTop, leftLegBottom, rightLegTop, rightLegBottom;
        let leftArmTop, leftArmBottom, rightArmTop, rightArmBottom;

        let playerVelocityY = 0;
        let isJumping = false;
        let isSliding = false;
        let currentLane = 0;
        let targetX = 0;
        
        let obstacles = [];
        let coins = [];
        let floorSegments = [];
        let sideElements = []; // 场边装饰
        
        let gameActive = false;
        let score = 0;
        let distance = 0;
        let speed = CONFIG.playerSpeedBase;
        let frameId;

        let ambientLight, dirLight;
        let skyColorCycle = 0; // 0-1 用于天空颜色插值

        // --- 初始化 Three.js ---
        function init() {
            scene = new THREE.Scene();
            // 初始天空颜色：凌晨4点深蓝紫色
            scene.background = new THREE.Color(0x0a0a2a);
            scene.fog = new THREE.Fog(scene.background, 30, 120);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 6, 10);
            camera.lookAt(0, 2, -5);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // 灯光系统
            ambientLight = new THREE.AmbientLight(0x333355, 0.4); // 初始偏冷暗光
            scene.add(ambientLight);

            dirLight = new THREE.DirectionalLight(0xffdcb4, 0.5); // 初始模拟月光/晨光
            dirLight.position.set(15, 20, 5);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 50;
            dirLight.shadow.camera.left = -15;
            dirLight.shadow.camera.right = 15;
            dirLight.shadow.camera.top = 15;
            dirLight.shadow.camera.bottom = -15;
            scene.add(dirLight);

            createPlayer();
            
            for(let i=0; i<20; i++) {
                spawnFloorSegment(i * 10);
            }

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', handleKeyDown);
            setupTouchControls();

            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', resetGame);
            document.getElementById('home-btn').addEventListener('click', navigateHome);
            document.getElementById('home-btn-over').addEventListener('click', navigateHome);

            render();
        }

        // --- 纹理生成 ---
        function createJerseyTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FDB927'; ctx.fillRect(0, 0, 256, 256);
            ctx.fillStyle = '#552583';
            ctx.fillRect(0, 0, 30, 256); ctx.fillRect(226, 0, 30, 256);
            // 领口和袖口边
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(30, 0, 196, 10);
            ctx.fillStyle = '#552583';
            ctx.font = 'bold 120px Impact, Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('24', 128, 128);
            ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 4;
            ctx.strokeText('24', 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function createBasketballTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#D65A16'; ctx.fillRect(0,0,128,128);
            ctx.strokeStyle = '#333333'; ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, 64); ctx.lineTo(128, 64);
            ctx.moveTo(64, 0); ctx.lineTo(64, 128);
            ctx.ellipse(64, 64, 60, 60, 0, 0, Math.PI * 2);
            ctx.stroke();
            // 增加一点颗粒感
            for(let i=0; i<500; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#C44A06' : '#E66A26';
                ctx.fillRect(Math.random()*128, Math.random()*128, 2, 2);
            }
            return new THREE.CanvasTexture(canvas);
        }

        // --- 创建更精细的科比模型 ---
        function createLimb(length, width, topRadius, bottomRadius, color) {
            const group = new THREE.Group();
            const geo = new THREE.CylinderGeometry(topRadius, bottomRadius, length, 12);
            const mat = new THREE.MeshLambertMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.y = -length / 2; // 旋转点在顶部
            mesh.castShadow = true;
            group.add(mesh);
            return group;
        }

        function createPlayer() {
            player = new THREE.Group();
            playerBodyGroup = new THREE.Group(); // 用于滑铲时的整体缩放
            player.add(playerBodyGroup);

            const skinColor = 0x5C4033;
            const jerseyMat = new THREE.MeshLambertMaterial({ map: createJerseyTexture() });
            const shortsMat = new THREE.MeshLambertMaterial({ color: CONFIG.colors.purple });

            // 1. 头
            const headGeo = new THREE.SphereGeometry(0.35, 16, 16);
            const headMat = new THREE.MeshLambertMaterial({ color: skinColor });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 2.6;
            playerBodyGroup.add(head);

            // 2. 躯干
            const torsoGeo = new THREE.BoxGeometry(0.8, 1.2, 0.4);
            const torso = new THREE.Mesh(torsoGeo, jerseyMat);
            torso.position.y = 1.8;
            torso.castShadow = true;
            playerBodyGroup.add(torso);

            // 3. 短裤
            const shortsGeo = new THREE.BoxGeometry(0.85, 0.6, 0.45);
            const shorts = new THREE.Mesh(shortsGeo, shortsMat);
            shorts.position.y = 0.9;
            shorts.castShadow = true;
            playerBodyGroup.add(shorts);

            // --- 腿部 (分为大腿和小腿) ---
            // 左大腿
            leftLegTop = createLimb(0.6, 0, 0.2, 0.15, shortsMat.color);
            leftLegTop.position.set(-0.25, 0.6, 0);
            playerBodyGroup.add(leftLegTop);
            // 左小腿
            leftLegBottom = createLimb(0.7, 0, 0.15, 0.1, skinColor);
            leftLegBottom.position.y = -0.6;
            leftLegTop.add(leftLegBottom);

            // 右大腿
            rightLegTop = createLimb(0.6, 0, 0.2, 0.15, shortsMat.color);
            rightLegTop.position.set(0.25, 0.6, 0);
            playerBodyGroup.add(rightLegTop);
            // 右小腿
            rightLegBottom = createLimb(0.7, 0, 0.15, 0.1, skinColor);
            rightLegBottom.position.y = -0.6;
            rightLegTop.add(rightLegBottom);

            // --- 手臂 (分为大臂和小臂) ---
            // 左大臂
            leftArmTop = createLimb(0.5, 0, 0.12, 0.1, skinColor);
            leftArmTop.position.set(-0.55, 2.3, 0);
            playerBodyGroup.add(leftArmTop);
            // 左小臂
            leftArmBottom = createLimb(0.5, 0, 0.1, 0.08, skinColor);
            leftArmBottom.position.y = -0.5;
            leftArmTop.add(leftArmBottom);

            // 右大臂
            rightArmTop = createLimb(0.5, 0, 0.12, 0.1, skinColor);
            rightArmTop.position.set(0.55, 2.3, 0);
            playerBodyGroup.add(rightArmTop);
            // 右小臂
            rightArmBottom = createLimb(0.5, 0, 0.1, 0.08, skinColor);
            rightArmBottom.position.y = -0.5;
            rightArmTop.add(rightArmBottom);

            scene.add(player);
            // 调整整体高度，让脚在地面
            playerBodyGroup.position.y = 0.1; 
        }

        // --- 环境与障碍物 ---
        function spawnFloorSegment(zPosition) {
            const geometry = new THREE.PlaneGeometry(15, 10);
            const material = new THREE.MeshPhongMaterial({ 
                color: CONFIG.colors.floor, specular: 0x111111, shininess: 5
            });
            const floor = new THREE.Mesh(geometry, material);
            floor.rotation.x = -Math.PI / 2;
            floor.position.z = -zPosition - 5;
            floor.receiveShadow = true;
            scene.add(floor);
            floorSegments.push(floor);

            const lineGeo = new THREE.PlaneGeometry(0.2, 10);
            const lineMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.floorLine });
            const leftLine = new THREE.Mesh(lineGeo, lineMat);
            leftLine.rotation.x = -Math.PI / 2; leftLine.position.set(-CONFIG.laneWidth/2, 0.01, 0);
            floor.add(leftLine);
            const rightLine = new THREE.Mesh(lineGeo, lineMat);
            rightLine.rotation.x = -Math.PI / 2; rightLine.position.set(CONFIG.laneWidth/2, 0.01, 0);
            floor.add(rightLine);

            // 添加场边装饰 (简易灯柱)
            if (zPosition % 30 === 0) {
                const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 8);
                const poleMat = new THREE.MeshLambertMaterial({color: 0x333333});
                
                const leftPole = new THREE.Mesh(poleGeo, poleMat);
                leftPole.position.set(-8, 4, floor.position.z);
                leftPole.castShadow = true;
                scene.add(leftPole);
                sideElements.push(leftPole);

                const rightPole = new THREE.Mesh(poleGeo, poleMat);
                rightPole.position.set(8, 4, floor.position.z);
                rightPole.castShadow = true;
                scene.add(rightPole);
                sideElements.push(rightPole);
            }

            if (zPosition > 30) {
                spawnObstaclesAndCoins(floor.position.z);
            }
        }

        function spawnObstaclesAndCoins(zPos) {
            const rand = Math.random();
            const lanes = [-CONFIG.laneWidth, 0, CONFIG.laneWidth];
            const laneIndex = Math.floor(Math.random() * 3);
            const xPos = lanes[laneIndex];

            // 45% 几率生成障碍物，随速度增加而增加
            let obstacleChance = 0.45 + (speed - CONFIG.playerSpeedBase) * 2;
            obstacleChance = Math.min(obstacleChance, 0.7);

            if (rand < obstacleChance) {
                const typeRand = Math.random();
                let obstacle;

                if (typeRand < 0.4) {
                    // 1. 防守者 (需要避开)
                    const obsGeo = new THREE.CylinderGeometry(0.6, 0.6, 2.5, 16);
                    const obsMat = new THREE.MeshLambertMaterial({ color: CONFIG.colors.obstacle });
                    obstacle = new THREE.Mesh(obsGeo, obsMat);
                    obstacle.position.set(xPos, 1.25, zPos);
                    obstacle.userData.type = 'avoider';
                } else if (typeRand < 0.7) {
                    // 2. 低栏架 (必须跳过)
                    const barGeo = new THREE.BoxGeometry(2.8, 0.8, 0.5);
                    const barMat = new THREE.MeshLambertMaterial({ color: CONFIG.colors.barrierLow });
                    obstacle = new THREE.Mesh(barGeo, barMat);
                    obstacle.position.set(xPos, 0.4, zPos);
                    obstacle.userData.type = 'umper';
                } else {
                    // 3. 高墙 (必须钻过)
                    const wallGeo = new THREE.BoxGeometry(2.8, 3, 0.5);
                    const wallMat = new THREE.MeshLambertMaterial({ color: CONFIG.colors.barrierHigh });
                    obstacle = new THREE.Mesh(wallGeo, wallMat);
                    // 高墙底部留空
                    obstacle.position.set(xPos, 3.5, zPos);
                    obstacle.userData.type = 'slider';
                }
                
                obstacle.castShadow = true;
                scene.add(obstacle);
                obstacles.push(obstacle);
            } 
            // 30% 几率生成篮球
            else if (rand > 0.65) {
                const coinGeo = new THREE.SphereGeometry(0.5, 16, 16);
                const coinMat = new THREE.MeshStandardMaterial({ 
                    map: createBasketballTexture(), roughness: 0.3, metalness: 0.1
                });
                const coin = new THREE.Mesh(coinGeo, coinMat);
                coin.position.set(xPos, 1.2, zPos);
                coin.castShadow = true;
                scene.add(coin);
                coins.push(coin);
            }
        }

        // --- 游戏控制与状态 ---
        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            gameActive = true;
            score = 0;
            distance = 0;
            speed = CONFIG.playerSpeedBase;
            currentLane = 0;
            targetX = 0;
            skyColorCycle = 0; // 重置时间

            player.position.set(0, 0, 0);
            player.rotation.set(0, 0, 0);
            playerBodyGroup.scale.set(1, 1, 1);
            playerBodyGroup.position.y = 0.1;
            
            updateScore();
            
            obstacles.forEach(o => scene.remove(o)); obstacles = [];
            coins.forEach(c => scene.remove(c)); coins = [];
            floorSegments.forEach(f => scene.remove(f)); floorSegments = [];
            sideElements.forEach(s => scene.remove(s)); sideElements = [];

            for(let i=0; i<20; i++) spawnFloorSegment(i * 10);
            if (!frameId) animate();
        }

        function resetGame() { startGame(); }
        function navigateHome() { window.location.href = '../index.html'; }
        function gameOver() {
            gameActive = false;
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('final-score').innerText = "得分: " + score;
        }
        function updateScore() {
            document.getElementById('score-display').innerText = "分数: " + score;
        }

        function moveLane(direction) {
            if (!gameActive) return;
            const newLane = currentLane + direction;
            if (newLane >= -1 && newLane <= 1) {
                currentLane = newLane;
                targetX = currentLane * CONFIG.laneWidth;
            }
        }

        function jump() {
            if (!gameActive || isJumping || isSliding) return;
            isJumping = true;
            // 初始向上的速度
            playerVelocityY = CONFIG.jumpHeight * 0.17;
        }

        function slide() {
            if (!gameActive || isJumping || isSliding) return;
            isSliding = true;
            // 压扁和降低身体
            playerBodyGroup.scale.y = 0.4;
            // 调整Y位置以贴地
            playerBodyGroup.position.y = -0.8; 
            setTimeout(() => {
                if (gameActive && isSliding) {
                    playerBodyGroup.scale.y = 1;
                    playerBodyGroup.position.y = 0.1;
                    isSliding = false;
                }
            }, 800);
        }

        function handleKeyDown(event) {
            switch(event.key) {
                case 'ArrowLeft': case 'a': moveLane(-1); break;
                case 'ArrowRight': case 'd': moveLane(1); break;
                case 'ArrowUp': case 'w': case ' ': jump(); break;
                case 'ArrowDown': case 's': slide(); break;
            }
        }

        function setupTouchControls() {
            let touchStartX = 0; let touchStartY = 0;
            document.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, {passive: false});
            document.addEventListener('touchend', (e) => {
                if(!gameActive) return;
                const diffX = e.changedTouches[0].screenX - touchStartX;
                const diffY = e.changedTouches[0].screenY - touchStartY;
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (Math.abs(diffX) > 30) moveLane(diffX > 0 ? 1 : -1);
                } else {
                    if (Math.abs(diffY) > 30) diffY < 0 ? jump() : slide();
                }
            }, {passive: false});
        }

        // --- 动画与主循环 ---
        function updateRunningAnim(time) {
            if (isJumping || isSliding) {
                // 跳跃/滑铲时姿势固定
                leftLegTop.rotation.x = isJumping ? -0.5 : 0.5;
                rightLegTop.rotation.x = isJumping ? 0.8 : 0.5;
                leftLegBottom.rotation.x = isJumping ? 1.2 : -1.0;
                rightLegBottom.rotation.x = 0.2;
                leftArmTop.rotation.x = -0.5; rightArmTop.rotation.x = -0.5;
                leftArmBottom.rotation.x = -0.5; rightArmBottom.rotation.x = -0.5;
                return;
            }
            // 跑步动画步频随速度增加
            const speedFactor = speed / CONFIG.playerSpeedBase;
            const t = time * 8 * speedFactor; 
            const legAmp = 0.8; const armAmp = 0.7;
            
            // 大腿
            leftLegTop.rotation.x = Math.sin(t) * legAmp;
            rightLegTop.rotation.x = Math.sin(t + Math.PI) * legAmp;
            // 小腿 (基于大腿动作的滞后和弯曲)
            leftLegBottom.rotation.x = Math.sin(t) < 0 ? 0.2 : Math.sin(t) * 0.8 + 0.2;
            rightLegBottom.rotation.x = Math.sin(t + Math.PI) < 0 ? 0.2 : Math.sin(t + Math.PI) * 0.8 + 0.2;

            // 大臂 (与对侧腿同步)
            leftArmTop.rotation.x = Math.sin(t + Math.PI) * armAmp;
            rightArmTop.rotation.x = Math.sin(t) * armAmp;
            // 小臂 (保持弯曲)
            leftArmBottom.rotation.x = -Math.abs(Math.sin(t + Math.PI) * 0.5) - 0.3;
            rightArmBottom.rotation.x = -Math.abs(Math.sin(t) * 0.5) - 0.3;
        }

        function updateEnvironmentCycle() {
            skyColorCycle += 0.0005 * (speed / CONFIG.playerSpeedBase);
            if (skyColorCycle > 1) skyColorCycle = 0;

            let skyColor, lightColor, lightIntensity, fogNear, fogFar;

            // 凌晨4点 -> 日出 -> 白天 -> 日落 -> 凌晨4点
            if (skyColorCycle < 0.2) { // 凌晨 (深蓝紫)
                skyColor = new THREE.Color(0x0a0a2a).lerp(new THREE.Color(0x3a2a5a), skyColorCycle*5);
                lightColor = new THREE.Color(0xffdcb4); lightIntensity = 0.5 + skyColorCycle;
                fogNear = 30; fogFar = 120;
            } else if (skyColorCycle < 0.3) { // 日出 (橙红)
                skyColor = new THREE.Color(0x3a2a5a).lerp(new THREE.Color(0xff7f50), (skyColorCycle-0.2)*10);
                lightColor = new THREE.Color(0xffaa55); lightIntensity = 0.8;
                fogNear = 40; fogFar = 150;
            } else if (skyColorCycle < 0.7) { // 白天 (亮蓝)
                skyColor = new THREE.Color(0xff7f50).lerp(new THREE.Color(0x87ceeb), (skyColorCycle-0.3)*2.5);
                lightColor = new THREE.Color(0xffffff); lightIntensity = 1.1;
                fogNear = 60; fogFar = 200;
            } else if (skyColorCycle < 0.8) { // 日落 (紫红)
                skyColor = new THREE.Color(0x87ceeb).lerp(new THREE.Color(0xcc6666), (skyColorCycle-0.7)*10);
                lightColor = new THREE.Color(0xff9966); lightIntensity = 0.8;
                fogNear = 40; fogFar = 150;
            } else { // 晚上 (回深蓝)
                skyColor = new THREE.Color(0xcc6666).lerp(new THREE.Color(0x0a0a2a), (skyColorCycle-0.8)*5);
                lightColor = new THREE.Color(0xccccff); lightIntensity = 0.5;
                fogNear = 30; fogFar = 120;
            }

            scene.background = skyColor;
            scene.fog.color = skyColor;
            scene.fog.near = fogNear; scene.fog.far = fogFar;
            dirLight.color = lightColor;
            dirLight.intensity = lightIntensity;
            ambientLight.intensity = lightIntensity * 0.4;
            // 让光源位置随时间轻微移动
            dirLight.position.x = Math.sin(skyColorCycle * Math.PI * 2) * 20;
            dirLight.position.y = Math.cos(skyColorCycle * Math.PI * 2) * 10 + 20;
        }

        function animate(time) {
            frameId = requestAnimationFrame(animate);
            if (!gameActive) return;
            
            time *= 0.001; // 转为秒

            // 1. 玩家更新
            player.position.x += (targetX - player.position.x) * 0.15;
            playerBodyGroup.rotation.z = (player.position.x - targetX) * -0.08; // 倾斜
            
            if (isJumping) {
                player.position.y += playerVelocityY;
                playerVelocityY -= CONFIG.gravity;
                if (player.position.y <= 0) {
                    player.position.y = 0; isJumping = false; playerVelocityY = 0;
                }
            }
            updateRunningAnim(time);

            // 2. 环境更新
            distance += speed;
            speed = Math.min(speed + CONFIG.speedAcceleration, CONFIG.playerSpeedMax);
            updateEnvironmentCycle();

            // 更新地板
            for (let i = floorSegments.length - 1; i >= 0; i--) {
                const floor = floorSegments[i]; floor.position.z += speed;
                if (floor.position.z > 10) {
                    let minZ = 0; floorSegments.forEach(f => minZ = Math.min(minZ, f.position.z));
                    floor.position.z = minZ - 10;
                    spawnObstaclesAndCoins(floor.position.z);
                }
            }
            // 更新侧边物体
            for(let i = sideElements.length - 1; i >= 0; i--) {
                const side = sideElements[i]; side.position.z += speed;
                if(side.position.z > 10) { scene.remove(side); sideElements.splice(i,1); }
            }

            // 3. 碰撞检测
            // 创建玩家的碰撞盒，根据状态调整
            const playerBox = new THREE.Box3();
            if (isSliding) {
                // 滑铲时碰撞盒变矮变宽
                playerBox.setFromCenterAndSize(
                    new THREE.Vector3(player.position.x, 0.3, 0),
                    new THREE.Vector3(0.7, 0.6, 0.5)
                );
            } else {
                // 正常/跳跃时
                playerBox.setFromCenterAndSize(
                    new THREE.Vector3(player.position.x, player.position.y + 1.3, 0),
                    new THREE.Vector3(0.7, 2.5, 0.5)
                );
            }

            // 更新障碍物
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i]; obs.position.z += speed;
                const obsBox = new THREE.Box3().setFromObject(obs);
                
                if (playerBox.intersectsBox(obsBox)) {
                    gameOver();
                }
                if (obs.position.z > 10) { scene.remove(obs); obstacles.splice(i, 1); }
            }

            // 更新金币
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i]; coin.position.z += speed;
                coin.rotation.y += 0.1; coin.rotation.x = Math.sin(time*2)*0.2;
                const coinBox = new THREE.Box3().setFromObject(coin);
                // 收集判定稍微宽松点
                coinBox.expandByScalar(0.2);
                if (playerBox.intersectsBox(coinBox)) {
                    score += 2; updateScore();
                    scene.remove(coin); coins.splice(i, 1); continue;
                }
                if (coin.position.z > 10) { scene.remove(coin); coins.splice(i, 1); }
            }

            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        init();
    </script>
</body>
</html>